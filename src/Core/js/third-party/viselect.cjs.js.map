{"version":3,"file":"viselect.cjs.js","sources":["../src/EventEmitter.ts","../src/utils/css.ts","../src/utils/events.ts","../src/utils/intersects.ts","../src/utils/selectAll.ts","../src/utils/constants.ts","../src/utils/deepAssign.ts","../src/index.ts","../src/utils/frames.ts"],"sourcesContent":["\n/* eslint-disable @typescript-eslint/no-explicit-any */\ntype AnyFunction = (...args: any[]) => any;\ntype EventMap = Record<string, AnyFunction>;\n\nexport class EventTarget<Events extends EventMap> {\n    private readonly _listeners = new Map<keyof Events, Set<AnyFunction>>();\n\n    public addEventListener<K extends keyof Events>(event: K, cb: Events[K]): this {\n        const set = this._listeners.get(event) || new Set();\n        this._listeners.set(event, set);\n        set.add(cb as AnyFunction);\n        return this;\n    }\n\n    public removeEventListener<K extends keyof Events>(event: K, cb: Events[K]): this {\n        this._listeners.get(event)?.delete(cb as AnyFunction);\n        return this;\n    }\n\n    public dispatchEvent<K extends keyof Events>(event: K, ...data: Parameters<Events[K]>): unknown {\n        let ok = true;\n        for (const cb of (this._listeners.get(event) || [])) {\n            ok = (cb(...data) !== false) && ok;\n        }\n\n        return ok;\n    }\n\n    public unbindAllListeners(): void {\n        this._listeners.clear();\n    }\n\n    // Let's also support on, off and emit like node\n    /* eslint-disable no-invalid-this */\n    public on = this.addEventListener;\n    public off = this.removeEventListener;\n    public emit = this.dispatchEvent;\n}\n","const unitify = (val: string | number, unit = 'px'): string => {\n    return typeof val === 'number' ? val + unit : val;\n};\n\n/**\n * Add css to a DOM-Element or returns the current\n * value of a property.\n *\n * @param el The Element.\n * @param attr The attribute or an object which holds css key-properties.\n * @param val The value for a single attribute.\n * @returns {*}\n */\nexport function css(\n    {style}: HTMLElement,\n    attr: Partial<Record<keyof CSSStyleDeclaration, string | number>> | string,\n    val?: string | number\n): void {\n    if (typeof attr === 'object') {\n\n        for (const [key, value] of Object.entries(attr)) {\n            value !== undefined && (style[key as any] = unitify(value));\n        }\n\n    } else if (val !== undefined) {\n        style[attr as any] = unitify(val);\n    }\n}\n\n\n","/* eslint-disable @typescript-eslint/explicit-module-boundary-types */\n/* eslint-disable @typescript-eslint/no-explicit-any */\ntype Method = 'addEventListener' | 'removeEventListener';\ntype AnyFunction = (...arg: any) => any;\n\nexport type EventBindingArgs = [\n        EventTarget | EventTarget[],\n        string | string[],\n    AnyFunction,\n    Record<string, unknown>?\n];\n\ninterface EventBinding {\n    (\n        elements: EventTarget | EventTarget[],\n        events: string | string[],\n        fn: AnyFunction,\n        options?: Record<string, unknown>\n    ): EventBindingArgs;\n}\n\n/* eslint-disable prefer-rest-params */\nfunction eventListener(method: Method): EventBinding {\n    return (\n        items: EventTarget | EventTarget[],\n        events: string | string[],\n        fn: AnyFunction, options = {}\n    ): EventBindingArgs => {\n\n        // Normalize array\n        if (items instanceof HTMLCollection || items instanceof NodeList) {\n            items = Array.from(items);\n        } else if (!Array.isArray(items)) {\n            items = [items];\n        }\n\n        if (!Array.isArray(events)) {\n            events = [events];\n        }\n\n        for (const el of items) {\n            for (const ev of events) {\n                el[method](ev, fn as EventListener, {capture: false, ...options});\n            }\n        }\n\n        return [items, events, fn, options];\n    };\n}\n\n/**\n * Add event(s) to element(s).\n * @param elements DOM-Elements\n * @param events Event names\n * @param fn Callback\n * @param options Optional options\n * @return Array passed arguments\n */\nexport const on = eventListener('addEventListener');\n\n/**\n * Remove event(s) from element(s).\n * @param elements DOM-Elements\n * @param events Event names\n * @param fn Callback\n * @param options Optional options\n * @return Array passed arguments\n */\nexport const off = eventListener('removeEventListener');\n\n/**\n * Simplifies a touch / mouse-event\n * @param evt\n */\nexport const simplifyEvent = (evt: any): {\n    target: HTMLElement;\n    x: number;\n    y: number;\n} => {\n    const { clientX, clientY, target } = (evt.touches && evt.touches[0] || evt);\n    return {x: clientX, y: clientY, target};\n};\n","export type Intersection = 'center' | 'cover' | 'touch'\n\n/**\n * Check if two DOM-Elements intersects each other.\n * @param a BoundingClientRect of the first element.\n * @param b BoundingClientRect of the second element.\n * @param mode Options are center, cover or touch.\n * @returns {boolean} If both elements intersects each other.\n */\nexport function intersects(a: DOMRect, b: DOMRect, mode: Intersection = 'touch'): boolean {\n    switch (mode) {\n        case 'center': {\n            const bxc = b.left + b.width / 2;\n            const byc = b.top + b.height / 2;\n\n            return bxc >= a.left &&\n                bxc <= a.right &&\n                byc >= a.top &&\n                byc <= a.bottom;\n        }\n        case 'cover': {\n            return b.left >= a.left &&\n                b.top >= a.top &&\n                b.right <= a.right &&\n                b.bottom <= a.bottom;\n        }\n        case 'touch': {\n            return a.right >= b.left &&\n                a.left <= b.right &&\n                a.bottom >= b.top &&\n                a.top <= b.bottom;\n        }\n    }\n}\n","export type SelectAllSelectors = readonly (string | Element)[] | string | Element;\n\n/**\n * Takes a selector (or array of selectors) and returns the matched nodes.\n * @param selector The selector or an Array of selectors.\n * @param doc\n * @returns {Array} Array of DOM-Nodes.\n */\nexport function selectAll(selector: SelectAllSelectors, doc: Document = document): Element[] {\n    const list = !Array.isArray(selector) ? [selector] : selector;\n    let nodes: Element[] = [];\n\n    for (let i = 0, l = list.length; i < l; i++) {\n        const item = list[i];\n\n        if (typeof item === 'string') {\n            /**\n             * We can't use the spread operator here as with large amounts of elements\n             * we'll get a \"Maximum call stack size exceeded\"-error.\n             */\n            nodes = nodes.concat(Array.from(doc.querySelectorAll(item)));\n        } else if (item instanceof Element) {\n            nodes.push(item);\n        }\n    }\n\n    return nodes;\n}\n","// Determines if the device's primary input supports touch\n// See this article: https://css-tricks.com/touch-devices-not-judged-size/\nexport const isTouchDevice = (): boolean => matchMedia('(hover: none), (pointer: coarse)').matches;\n\n// Determines if the browser is safari\nexport const isSafariBrowser = (): boolean => 'safari' in window;\n","/* eslint-disable @typescript-eslint/no-explicit-any */\n/* eslint-disable @typescript-eslint/explicit-module-boundary-types */\nexport const deepAssign = <O extends Record<any, any>>(target: O, source: any): O => {\n    for (const [key, value] of Object.entries(target)) {\n        const sourceValue = source[key];\n\n        // Use the default value if there's no value specified\n        target[key as keyof O] = sourceValue === undefined ? target[key as keyof O] :\n\n            // Check if it's a nested object and merge if required\n            (typeof sourceValue === 'object' && typeof value === 'object' && value !== null && !Array.isArray(value)) ?\n                deepAssign(value as O, sourceValue as Partial<O>) : sourceValue;\n    }\n\n    return target;\n};\n","import {EventTarget} from './EventEmitter';\nimport type {AreaLocation, Coordinates, ScrollEvent, SelectionEvents, SelectionOptions, SelectionStore} from './types';\nimport {PartialSelectionOptions} from './types';\nimport {css, deepAssign, frames, Frames, intersects, isSafariBrowser, isTouchDevice, off, on, selectAll, SelectAllSelectors, simplifyEvent} from './utils';\n\n// Re-export types\nexport * from './types';\n\n// Some var shorting for better compression and readability\nconst {abs, max, min, ceil} = Math;\n\nexport default class SelectionArea extends EventTarget<SelectionEvents> {\n    public static version = VERSION;\n\n    // Options\n    private readonly _options: SelectionOptions;\n\n    // Selection store\n    private _selection: SelectionStore = {\n        stored: [],\n        selected: [],\n        touched: [],\n        changed: {\n            added: [], // Added elements since last selection\n            removed: [] // Removed elements since last selection\n        }\n    };\n\n    // Area element and clipping element\n    private readonly _area: HTMLElement;\n    private readonly _clippingElement: HTMLElement;\n\n    // Target container (element) and boundary (cached)\n    private _targetElement?: Element;\n    private _targetRect?: DOMRect;\n    private _selectables: Element[] = [];\n    private _latestElement?: Element;\n\n    // Caches the position of the selection-area\n    private readonly _areaRect = new DOMRect();\n\n    // Dynamically constructed area rect\n    private _areaLocation: AreaLocation = {y1: 0, x2: 0, y2: 0, x1: 0};\n\n    // If a single click is being performed.\n    // It's a single-click until the user dragged the mouse.\n    private _singleClick = true;\n    private _frame: Frames;\n\n    // Is getting set on movement.\n    private _scrollAvailable = true;\n    private _scrollingActive = false;\n    private _scrollSpeed: Coordinates = {x: 0, y: 0};\n    private _scrollDelta: Coordinates = {x: 0, y: 0};\n\n    constructor(opt: PartialSelectionOptions) {\n        super();\n\n        this._options = deepAssign<SelectionOptions>({\n            selectionAreaClass: 'selection-area',\n            selectionContainerClass: undefined,\n            selectables: [],\n            document: window.document,\n\n            behaviour: {\n                overlap: 'invert',\n                intersect: 'touch',\n                startThreshold: {x: 10, y: 10},\n                scrolling: {\n                    speedDivider: 10,\n                    manualSpeed: 750,\n                    startScrollMargins: {x: 0, y: 0}\n                }\n            },\n\n            features: {\n                range: true,\n                touch: true,\n                singleTap: {\n                    allow: true,\n                    intersect: 'native'\n                }\n            },\n\n            startAreas: ['html'],\n            boundaries: ['html'],\n            container: 'body'\n        }, opt);\n\n        // Bind locale functions to instance\n        /* eslint-disable @typescript-eslint/no-explicit-any */\n        for (const key of Object.getOwnPropertyNames(Object.getPrototypeOf(this))) {\n            if (typeof (this as any)[key] === 'function') {\n                (this as any)[key] = (this as any)[key].bind(this);\n            }\n        }\n\n        const {document, selectionAreaClass, selectionContainerClass} = this._options;\n        this._area = document.createElement('div');\n        this._clippingElement = document.createElement('div');\n        this._clippingElement.appendChild(this._area);\n\n        this._area.classList.add(selectionAreaClass);\n        selectionContainerClass && this._clippingElement.classList.add(selectionContainerClass);\n\n        css(this._area, {\n            willChange: 'top, left, bottom, right, width, height',\n            top: 0,\n            left: 0,\n            position: 'fixed'\n        });\n\n        css(this._clippingElement, {\n            overflow: 'hidden',\n            position: 'fixed',\n            transform: 'translate3d(0, 0, 0)', // https://stackoverflow.com/a/38268846\n            pointerEvents: 'none',\n            zIndex: '1'\n        });\n\n        this._frame = frames((evt: MouseEvent | TouchEvent) => {\n            this._recalculateSelectionAreaRect();\n            this._updateElementSelection();\n            this._emitEvent('move', evt);\n            this._redrawSelectionArea();\n        });\n\n        this.enable();\n    }\n\n    _bindStartEvents(activate = true): void {\n        const {document, features} = this._options;\n        const fn = activate ? on : off;\n\n        fn(document, 'mousedown', this._onTapStart);\n        features.touch && fn(document, 'touchstart', this._onTapStart, {\n            passive: false\n        });\n    }\n\n    _onTapStart(evt: MouseEvent | TouchEvent, silent = false): void {\n        const {x, y, target} = simplifyEvent(evt);\n        const {_options} = this;\n        const {document} = this._options;\n        const targetBoundingClientRect = target.getBoundingClientRect();\n\n        // Find start-areas and boundaries\n        const startAreas = selectAll(_options.startAreas, _options.document);\n        const resolvedBoundaries = selectAll(_options.boundaries, _options.document);\n\n        // Check in which container the user started the selection\n        this._targetElement = resolvedBoundaries.find(el =>\n            intersects(el.getBoundingClientRect(), targetBoundingClientRect)\n        );\n\n        // Check if area starts in one of the start areas / boundaries\n        const evtPath = evt.composedPath();\n        if (!this._targetElement ||\n            !startAreas.find(el => evtPath.includes(el)) ||\n            !resolvedBoundaries.find(el => evtPath.includes(el))) {\n            return;\n        }\n\n        if (!silent && this._emitEvent('beforestart', evt) === false) {\n            return;\n        }\n\n        this._areaLocation = {x1: x, y1: y, x2: 0, y2: 0};\n\n        // Lock scrolling in target container\n        const scrollElement = document.scrollingElement || document.body;\n        this._scrollDelta = {x: scrollElement.scrollLeft, y: scrollElement.scrollTop};\n\n        // To detect single-click\n        this._singleClick = true;\n        this.clearSelection(false);\n\n        on(document, ['touchmove', 'mousemove'], this._delayedTapMove, {passive: false});\n        on(document, ['mouseup', 'touchcancel', 'touchend'], this._onTapStop);\n        on(document, 'scroll', this._onScroll);\n    }\n\n    _onSingleTap(evt: MouseEvent | TouchEvent): void {\n        const {singleTap: {intersect}, range} = this._options.features;\n        const e = simplifyEvent(evt);\n        let target;\n\n        if (intersect === 'native') {\n            target = e.target;\n        } else if (intersect === 'touch') {\n            this.resolveSelectables();\n\n            const {x, y} = e;\n            target = this._selectables.find(v => {\n                const {right, left, top, bottom} = v.getBoundingClientRect();\n                return x < right && x > left && y < bottom && y > top;\n            });\n        }\n\n        if (!target) {\n            return;\n        }\n\n        /**\n         * Resolve selectables again.\n         * If the user started in a scrollable area they will be reduced\n         * to the current area. Prevent the exclusion of these if a range-selection\n         * gets performed.\n         */\n        this.resolveSelectables();\n\n        // Traverse dom upwards to check if target is selectable\n        while (!this._selectables.includes(target)) {\n            if (!target.parentElement) {\n                return;\n            }\n\n            target = target.parentElement;\n        }\n\n        // Grab current store first in case it gets set back\n        const {stored} = this._selection;\n        this._emitEvent('start', evt);\n\n        if (evt.shiftKey && stored.length && range) {\n            const reference = this._latestElement ?? stored[0];\n\n            // Resolve correct range\n            const [preceding, following] = reference.compareDocumentPosition(target) & 4 ?\n                [target, reference] : [reference, target];\n\n            const rangeItems = [...this._selectables.filter(el =>\n                (el.compareDocumentPosition(preceding) & 4) &&\n                (el.compareDocumentPosition(following) & 2)\n            ), preceding, following];\n\n            this.select(rangeItems);\n        } else if (\n            stored.includes(target) && (\n                stored.length === 1 || evt.ctrlKey ||\n                stored.every(v => this._selection.stored.includes(v))\n            )\n        ) {\n            this.deselect(target);\n        } else {\n            this._latestElement = target;\n            this.select(target);\n        }\n\n        this._emitEvent('stop', evt);\n    }\n\n    _delayedTapMove(evt: MouseEvent | TouchEvent): void {\n        const {container, document, behaviour: {startThreshold}} = this._options;\n        const {x1, y1} = this._areaLocation; // Coordinates of first \"tap\"\n        const {x, y} = simplifyEvent(evt);\n\n        // Check pixel threshold\n        const thresholdType = typeof startThreshold;\n        if (\n\n            // Single number for both coordinates\n            (thresholdType === 'number' && abs((x + y) - (x1 + y1)) >= startThreshold) ||\n\n            // Different x and y threshold\n            (thresholdType === 'object' && abs(x - x1) >= (startThreshold as Coordinates).x || abs(y - y1) >= (startThreshold as Coordinates).y)\n        ) {\n            off(document, ['mousemove', 'touchmove'], this._delayedTapMove, {passive: false});\n\n            if (this._emitEvent('beforedrag', evt) === false) {\n                off(document, ['mouseup', 'touchcancel', 'touchend'], this._onTapStop);\n                return;\n            }\n\n            on(document, ['mousemove', 'touchmove'], this._onTapMove, {passive: false});\n\n            // Make area element visible\n            css(this._area, 'display', 'block');\n\n            // Append selection-area to the dom\n            selectAll(container, document)[0].appendChild(this._clippingElement);\n\n            this.resolveSelectables();\n\n            // An action is recognized as single-select until the user performed a multi-selection\n            this._singleClick = false;\n\n            // Just saving the boundaries of this container for later\n            this._targetRect = this._targetElement!.getBoundingClientRect();\n\n            // Find container and check if it's scrollable\n            this._scrollAvailable =\n                this._targetElement!.scrollHeight !== this._targetElement!.clientHeight ||\n                this._targetElement!.scrollWidth !== this._targetElement!.clientWidth;\n\n            if (this._scrollAvailable) {\n\n                // Detect mouse scrolling\n                on(document, 'wheel', this._manualScroll, {passive: false});\n\n                /**\n                 * The selection-area will also cover other element which are\n                 * out of the current scrollable parent. So find all elements\n                 * which are in the current scrollable element. Later these are\n                 * the only selectables instead of all.\n                 */\n                this._selectables = this._selectables.filter(s => this._targetElement!.contains(s));\n            }\n\n            // Re-setup selection area and fire event\n            this._setupSelectionArea();\n            this._emitEvent('start', evt);\n            this._onTapMove(evt);\n        }\n\n        this._handleMoveEvent(evt);\n    }\n\n    _setupSelectionArea(): void {\n        const {_clippingElement, _targetElement, _area} = this;\n        const tr = this._targetRect = _targetElement!.getBoundingClientRect();\n\n        if (this._scrollAvailable) {\n\n            /**\n             * To clip the area, the selection area has a parent\n             * which has exact the same dimensions as the scrollable element.\n             * Now if the area exceeds these boundaries it will be cropped.\n             */\n            css(_clippingElement, {\n                top: tr.top,\n                left: tr.left,\n                width: tr.width,\n                height: tr.height\n            });\n\n            /**\n             * The area element is relative to the clipping element,\n             * but when this is moved or transformed we need to correct\n             * the positions via a negative margin.\n             */\n            css(_area, {\n                marginTop: -tr.top,\n                marginLeft: -tr.left\n            });\n        } else {\n\n            // \"Reset\" styles\n            css(_clippingElement, {\n                top: 0,\n                left: 0,\n                width: '100%',\n                height: '100%'\n            });\n\n            css(_area, {\n                marginTop: 0,\n                marginLeft: 0\n            });\n        }\n    }\n\n    _onTapMove(evt: MouseEvent | TouchEvent): void {\n        const {x, y} = simplifyEvent(evt);\n        const {_scrollSpeed, _areaLocation, _options, _frame} = this;\n        const {speedDivider} = _options.behaviour.scrolling;\n        const _targetElement = this._targetElement as Element;\n\n        _areaLocation.x2 = x;\n        _areaLocation.y2 = y;\n\n        if (this._scrollAvailable && !this._scrollingActive && (_scrollSpeed.y || _scrollSpeed.x)) {\n\n            // Continuous scrolling\n            this._scrollingActive = true;\n\n            const scroll = () => {\n                if (!_scrollSpeed.x && !_scrollSpeed.y) {\n                    this._scrollingActive = false;\n                    return;\n                }\n\n                // Reduce velocity, use ceil in both directions to scroll at least 1px per frame\n                if (_scrollSpeed.y) {\n                    const distance = ceil(_scrollSpeed.y / speedDivider);\n                    _targetElement.scrollTop += distance;\n                    _areaLocation.y1 -= distance;\n                }\n\n                if (_scrollSpeed.x) {\n                    const distance = ceil(_scrollSpeed.x / speedDivider);\n                    _targetElement.scrollLeft += distance;\n                    _areaLocation.x1 -= distance;\n                }\n\n                /**\n                 * We changed the start coordinates -> redraw the selection-area\n                 * We changed the dimensions of the area element -> re-calc selected elements\n                 * The selected elements array has been changed -> fire event\n                 */\n                _frame.next(evt);\n\n                // Keep scrolling even if the user stops to move his pointer\n                requestAnimationFrame(scroll);\n            };\n\n            requestAnimationFrame(scroll);\n        } else {\n\n            /**\n             * Perform redraw only if scrolling is not active.\n             * If scrolling is active this area is getting re-dragged by the\n             * anonymize scroll function.\n             */\n            _frame.next(evt);\n        }\n\n        this._handleMoveEvent(evt);\n    }\n\n    _handleMoveEvent(evt: MouseEvent | TouchEvent) {\n        const {features} = this._options;\n\n        /**\n         * - Prevent auto-refresh for when pulling down on touch devices.\n         * - Prevent auto-scroll by the browser when on safari and scrolling is handled by viselect.\n         */\n        if ((features.touch && isTouchDevice()) || (this._scrollAvailable && isSafariBrowser())) {\n            evt.preventDefault(); // Prevent swipe-down refresh\n        }\n    }\n\n    _onScroll(): void {\n        const {_scrollDelta, _options: {document}} = this;\n        const {scrollTop, scrollLeft} = document.scrollingElement || document.body;\n\n        // Adjust area start location\n        this._areaLocation.x1 += _scrollDelta.x - scrollLeft;\n        this._areaLocation.y1 += _scrollDelta.y - scrollTop;\n        _scrollDelta.x = scrollLeft;\n        _scrollDelta.y = scrollTop;\n\n        // The area needs to be set back as the target-container has changed in its position\n        this._setupSelectionArea();\n        this._frame.next(null);\n    }\n\n    _manualScroll(evt: ScrollEvent): void {\n        const {manualSpeed} = this._options.behaviour.scrolling;\n\n        // Consistent scrolling speed on all browsers\n        const deltaY = evt.deltaY ? (evt.deltaY > 0 ? 1 : -1) : 0;\n        const deltaX = evt.deltaX ? (evt.deltaX > 0 ? 1 : -1) : 0;\n        this._scrollSpeed.y += deltaY * manualSpeed;\n        this._scrollSpeed.x += deltaX * manualSpeed;\n        this._onTapMove(evt);\n\n        // Prevent default scrolling behaviour, e.g. page scrolling\n        evt.preventDefault();\n    }\n\n    _recalculateSelectionAreaRect(): void {\n        const {_scrollSpeed, _areaLocation, _areaRect, _targetElement, _options} = this;\n        const {scrollTop, scrollHeight, clientHeight, scrollLeft, scrollWidth, clientWidth} = _targetElement as Element;\n        const _targetRect = this._targetRect as DOMRect;\n\n        const {x1, y1} = _areaLocation;\n        let {x2, y2} = _areaLocation;\n\n        const {behaviour: {scrolling: {startScrollMargins}}} = _options;\n\n        if (x2 < _targetRect.left + startScrollMargins.x) {\n            _scrollSpeed.x = scrollLeft ? -abs(_targetRect.left - x2 + startScrollMargins.x) : 0;\n            x2 = x2 < _targetRect.left ? _targetRect.left : x2;\n        } else if (x2 > _targetRect.right - startScrollMargins.x) {\n            _scrollSpeed.x = scrollWidth - scrollLeft - clientWidth ? abs(_targetRect.left + _targetRect.width - x2 - startScrollMargins.x) : 0;\n            x2 = x2 > _targetRect.right ? _targetRect.right : x2;\n        } else {\n            _scrollSpeed.x = 0;\n        }\n\n        if (y2 < _targetRect.top + startScrollMargins.y) {\n            _scrollSpeed.y = scrollTop ? -abs(_targetRect.top - y2 + startScrollMargins.y) : 0;\n            y2 = y2 < _targetRect.top ? _targetRect.top : y2;\n        } else if (y2 > _targetRect.bottom - startScrollMargins.y) {\n            _scrollSpeed.y = scrollHeight - scrollTop - clientHeight ? abs(_targetRect.top + _targetRect.height - y2 - startScrollMargins.y) : 0;\n            y2 = y2 > _targetRect.bottom ? _targetRect.bottom : y2;\n        } else {\n            _scrollSpeed.y = 0;\n        }\n\n        const x3 = min(x1, x2);\n        const y3 = min(y1, y2);\n        const x4 = max(x1, x2);\n        const y4 = max(y1, y2);\n\n        _areaRect.x = x3;\n        _areaRect.y = y3;\n        _areaRect.width = x4 - x3;\n        _areaRect.height = y4 - y3;\n    }\n\n    _redrawSelectionArea(): void {\n        const {x, y, width, height} = this._areaRect;\n        const {style} = this._area;\n\n        // Using transform will make the area's borders look blurry\n        style.left = `${x}px`;\n        style.top = `${y}px`;\n        style.width = `${width}px`;\n        style.height = `${height}px`;\n    }\n\n    _onTapStop(evt: MouseEvent | TouchEvent | null, silent: boolean): void {\n        const {document, features} = this._options;\n        const {_singleClick} = this;\n\n        // Remove event handlers\n        off(document, ['mousemove', 'touchmove'], this._delayedTapMove);\n        off(document, ['touchmove', 'mousemove'], this._onTapMove);\n        off(document, ['mouseup', 'touchcancel', 'touchend'], this._onTapStop);\n        off(document, 'scroll', this._onScroll);\n\n        // Keep selection until the next time\n        this._keepSelection();\n\n        if (evt && _singleClick && features.singleTap.allow) {\n            this._onSingleTap(evt);\n        } else if (!_singleClick && !silent) {\n            this._updateElementSelection();\n            this._emitEvent('stop', evt);\n        }\n\n        this._scrollSpeed.x = 0;\n        this._scrollSpeed.y = 0;\n\n        // Unbind mouse scrolling listener\n        this._scrollAvailable && off(document, 'wheel', this._manualScroll, {passive: true});\n\n        // Remove selection-area from dom\n        this._clippingElement.remove();\n\n        // Cancel current frame\n        this._frame?.cancel();\n\n        // Hide selection area\n        css(this._area, 'display', 'none');\n    }\n\n    _updateElementSelection(): void {\n        const {_selectables, _options, _selection, _areaRect} = this;\n        const {stored, selected, touched} = _selection;\n        const {intersect, overlap} = _options.behaviour;\n\n        const invert = overlap === 'invert';\n        const newlyTouched: Element[] = [];\n        const added: Element[] = [];\n        const removed: Element[] = [];\n\n        // Find newly selected elements\n        for (let i = 0; i < _selectables.length; i++) {\n            const node = _selectables[i];\n\n            // Check if area intersects element\n            if (intersects(_areaRect, node.getBoundingClientRect(), intersect)) {\n\n                // Check if the element wasn't present in the last selection.\n                if (!selected.includes(node)) {\n\n                    // Check if user wants to invert the selection for already selected elements\n                    if (invert && stored.includes(node)) {\n                        removed.push(node);\n                        continue;\n                    } else {\n                        added.push(node);\n                    }\n                } else if (stored.includes(node) && !touched.includes(node)) {\n                    touched.push(node);\n                }\n\n                newlyTouched.push(node);\n            }\n        }\n\n        // Re-select elements which were previously stored\n        if (invert) {\n            added.push(...stored.filter(v => !selected.includes(v)));\n        }\n\n        // Check which elements where removed since last selection\n        const keep = overlap === 'keep';\n        for (let i = 0; i < selected.length; i++) {\n            const node = selected[i];\n\n            if (!newlyTouched.includes(node) && !(\n\n                // Check if user wants to keep previously selected elements, e.g.\n                // not make them part of the current selection as soon as they're touched.\n                keep && stored.includes(node)\n            )) {\n                removed.push(node);\n            }\n        }\n\n        _selection.selected = newlyTouched;\n        _selection.changed = {added, removed};\n        this._latestElement = newlyTouched[newlyTouched.length - 1];\n    }\n\n    _emitEvent(name: keyof SelectionEvents, evt: MouseEvent | TouchEvent | null): unknown {\n        return this.emit(name, {\n            event: evt,\n            store: this._selection,\n            selection: this\n        });\n    }\n\n    _keepSelection(): void {\n        const {_options, _selection} = this;\n        const {selected, changed, touched, stored} = _selection;\n        const addedElements = selected.filter(el => !stored.includes(el));\n\n        switch (_options.behaviour.overlap) {\n            case 'drop': {\n                _selection.stored = [\n                    ...addedElements,\n                    ...stored.filter(el => !touched.includes(el))  // Elements not touched\n                ];\n                break;\n            }\n            case 'invert': {\n                _selection.stored = [\n                    ...addedElements,\n                    ...stored.filter(el => !changed.removed.includes(el))  // Elements not removed from selection\n                ];\n                break;\n            }\n            case 'keep': {\n                _selection.stored = [\n                    ...stored,\n                    ...selected.filter(el => !stored.includes(el)) // Newly added\n                ];\n                break;\n            }\n        }\n    }\n\n    /**\n     * Can be used if during a selection elements have been added.\n     * Will update everything which can be selected.\n     */\n    resolveSelectables(): void {\n        this._selectables = selectAll(this._options.selectables, this._options.document);\n    }\n\n    /**\n     * Same as deselect, but for all elements currently selected.\n     * @param includeStored If the store should also get cleared\n     * @param quiet If move / stop events should be fired\n     */\n    clearSelection(includeStored = true, quiet = false): void {\n        const {selected, stored, changed} = this._selection;\n\n        changed.added = [];\n        changed.removed.push(\n            ...selected,\n            ...(includeStored ? stored : [])\n        );\n\n        // Fire event\n        if (!quiet) {\n            this._emitEvent('move', null);\n            this._emitEvent('stop', null);\n        }\n\n        // Reset state\n        this._latestElement = undefined;\n        this._selection = {\n            stored: includeStored ? [] : stored,\n            selected: [],\n            touched: [],\n            changed: {added: [], removed: []}\n        };\n    }\n\n    /**\n     * @returns {Array} Selected elements\n     */\n    getSelection(): Element[] {\n        return this._selection.stored;\n    }\n\n    /**\n     * @returns {HTMLElement} The selection area element\n     */\n    getSelectionArea(): HTMLElement {\n        return this._area;\n    }\n\n    /**\n     * Cancel the current selection process.\n     * @param keepEvent {boolean} true to fire a stop event after cancel.\n     */\n    cancel(keepEvent = false): void {\n        this._onTapStop(null, !keepEvent);\n    }\n\n    /**\n     * Unbinds all events and removes the area-element.\n     */\n    destroy(): void {\n        this.cancel();\n        this.disable();\n        this._clippingElement.remove();\n        super.unbindAllListeners();\n    }\n\n    /* eslint-disable no-invalid-this */\n    disable = this._bindStartEvents.bind(this, false);\n    enable = this._bindStartEvents;\n\n    /**\n     * Adds elements to the selection\n     * @param query - CSS Query, can be an array of queries\n     * @param quiet - If this should not trigger the move event\n     */\n    select(query: SelectAllSelectors, quiet = false): Element[] {\n        const {changed, selected, stored} = this._selection;\n        const elements = selectAll(query, this._options.document).filter(el =>\n            !selected.includes(el) &&\n            !stored.includes(el)\n        );\n\n        // Update element lists\n        stored.push(...elements);\n        selected.push(...elements);\n        changed.added.push(...elements);\n        changed.removed = [];\n\n        // We don't know which element was \"selected\" first so clear it\n        this._latestElement = undefined;\n\n        // Fire event\n        if (!quiet) {\n            this._emitEvent('move', null);\n            this._emitEvent('stop', null);\n        }\n\n        return elements;\n    }\n\n    /**\n     * Removes a particular element from the selection.\n     * @param query - CSS Query, can be an array of queries\n     * @param quiet - If this should not trigger the move event\n     */\n    deselect(query: SelectAllSelectors, quiet = false) {\n        const {selected, stored, changed} = this._selection;\n\n        const elements = selectAll(query, this._options.document).filter(el =>\n            selected.includes(el) ||\n            stored.includes(el)\n        );\n\n        if (!elements.length) {\n            return;\n        }\n\n        this._selection.stored = stored.filter(el => !elements.includes(el));\n        this._selection.selected = selected.filter(el => !elements.includes(el));\n        this._selection.changed.added = [];\n        this._selection.changed.removed.push(\n            ...elements.filter(el => !changed.removed.includes(el))\n        );\n\n        // We don't know which element was \"selected\" first so clear it\n        this._latestElement = undefined;\n\n        // Fire event\n        if (!quiet) {\n            this._emitEvent('move', null);\n            this._emitEvent('stop', null);\n        }\n    }\n}\n","/* eslint-disable @typescript-eslint/no-explicit-any */\ntype AnyFunction = (...args: any[]) => void;\n\nexport interface Frames<F extends AnyFunction = AnyFunction> {\n    next(...args: Parameters<F>): void;\n\n    cancel(): void;\n}\n\nexport const frames = <F extends AnyFunction>(fn: F): Frames<F> => {\n    let previousArgs: Parameters<F>;\n    let frameId = -1;\n    let lock = false;\n\n    return {\n        next(...args: Parameters<F>): void {\n            previousArgs = args;\n\n            if (!lock) {\n                lock = true;\n                frameId = requestAnimationFrame(() => {\n                    fn(...previousArgs);\n                    lock = false;\n                });\n            }\n        },\n        cancel() {\n            cancelAnimationFrame(frameId);\n            lock = false;\n        }\n    };\n};\n"],"names":["EventTarget","constructor","this","_listeners","Map","on","addEventListener","off","removeEventListener","emit","dispatchEvent","event","cb","set","get","Set","add","delete","data","ok","unbindAllListeners","clear","unitify","val","unit","css","style","attr","key","value","Object","entries","undefined","eventListener","method","items","events","fn","options","HTMLCollection","NodeList","Array","from","isArray","el","ev","capture","simplifyEvent","evt","clientX","clientY","target","touches","x","y","intersects","a","b","mode","bxc","left","width","byc","top","height","right","bottom","selectAll","selector","doc","document","list","nodes","i","l","length","item","concat","querySelectorAll","Element","push","deepAssign","source","sourceValue","abs","max","min","ceil","Math","SelectionArea","opt","super","_selection","stored","selected","touched","changed","added","removed","_selectables","_areaRect","DOMRect","_areaLocation","y1","x2","y2","x1","_singleClick","_scrollAvailable","_scrollingActive","_scrollSpeed","_scrollDelta","disable","_bindStartEvents","bind","enable","_options","selectionAreaClass","selectionContainerClass","selectables","window","behaviour","overlap","intersect","startThreshold","scrolling","speedDivider","manualSpeed","startScrollMargins","features","range","touch","singleTap","allow","startAreas","boundaries","container","getOwnPropertyNames","getPrototypeOf","_area","createElement","_clippingElement","appendChild","classList","willChange","position","overflow","transform","pointerEvents","zIndex","_frame","previousArgs","frameId","lock","next","args","requestAnimationFrame","cancel","cancelAnimationFrame","frames","_recalculateSelectionAreaRect","_updateElementSelection","_emitEvent","_redrawSelectionArea","activate","_onTapStart","passive","silent","S","targetBoundingClientRect","getBoundingClientRect","resolvedBoundaries","_targetElement","find","evtPath","composedPath","includes","scrollElement","scrollingElement","body","scrollLeft","scrollTop","clearSelection","_delayedTapMove","_onTapStop","_onScroll","_onSingleTap","e","resolveSelectables","v","parentElement","shiftKey","reference","_latestElement","preceding","following","compareDocumentPosition","rangeItems","filter","select","ctrlKey","every","deselect","thresholdType","_onTapMove","_targetRect","scrollHeight","clientHeight","scrollWidth","clientWidth","_manualScroll","s","contains","_setupSelectionArea","_handleMoveEvent","T","D","A","tr","marginTop","marginLeft","L","scroll","distance","matchMedia","matches","preventDefault","g","deltaY","deltaX","h","x3","y3","x4","y4","u","_keepSelection","remove","o","invert","newlyTouched","node","keep","name","store","selection","addedElements","includeStored","quiet","getSelection","getSelectionArea","keepEvent","destroy","query","elements","version"],"mappings":"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"}