{"version":3,"file":"viselect.umd.js","sources":["../src/EventEmitter.ts","../src/utils/css.ts","../src/utils/domRect.ts","../src/utils/frames.ts","../src/utils/intersects.ts","../src/utils/browser.ts","../src/utils/arrayify.ts","../src/utils/events.ts","../src/utils/selectAll.ts","../src/utils/matchesTrigger.ts","../src/index.ts"],"sourcesContent":["\n/* eslint-disable @typescript-eslint/no-explicit-any */\ntype AnyFunction = (...args: any[]) => any;\ntype EventMap = Record<string, AnyFunction>;\n\nexport class EventTarget<Events extends EventMap> {\n    private readonly _listeners = new Map<keyof Events, Set<AnyFunction>>();\n\n    public addEventListener<K extends keyof Events>(event: K, cb: Events[K]): this {\n        const set = this._listeners.get(event) ?? new Set();\n        this._listeners.set(event, set);\n        set.add(cb as AnyFunction);\n        return this;\n    }\n\n    public removeEventListener<K extends keyof Events>(event: K, cb: Events[K]): this {\n        this._listeners.get(event)?.delete(cb as AnyFunction);\n        return this;\n    }\n\n    public dispatchEvent<K extends keyof Events>(event: K, ...data: Parameters<Events[K]>): boolean {\n        let ok = true;\n        for (const cb of (this._listeners.get(event) ?? [])) {\n            ok = (cb(...data) !== false) && ok;\n        }\n\n        return ok;\n    }\n\n    public unbindAllListeners(): void {\n        this._listeners.clear();\n    }\n\n    // Let's also support on, off and emit like node\n    public on = this.addEventListener;\n    public off = this.removeEventListener;\n    public emit = this.dispatchEvent;\n}\n","const unitify = (val: string | number, unit = 'px'): string => {\n    return typeof val === 'number' ? val + unit : val;\n};\n\n/**\n * Add css to a DOM-Element or returns the current\n * value of a property.\n *\n * @param el The Element.\n * @param attr The attribute or an object which holds css key-properties.\n * @param val The value for a single attribute.\n * @returns {*}\n */\nexport const css = ({style}: HTMLElement, attr: Partial<Record<keyof CSSStyleDeclaration, string | number>> | string, val?: string | number): void => {\n    if (typeof attr === 'object') {\n        for (const [key, value] of Object.entries(attr)) {\n            if (value !== undefined) {\n                // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                style[key as any] = unitify(value);\n            }\n        }\n    } else if (val !== undefined) {\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        style[attr as any] = unitify(val);\n    }\n};\n\n","// Polyfill for DOMRect as happy-dom and jsdom don't support it\nexport const domRect = (x = 0, y = 0, width = 0, height = 0): DOMRect => {\n    const rect = {x, y, width, height, top: y, left: x, right: x + width, bottom: y + height};\n    const toJSON = () => JSON.stringify(rect);\n    return {...rect, toJSON};\n};\n","/* eslint-disable @typescript-eslint/no-explicit-any */\ntype AnyFunction = (...args: any[]) => void;\n\nexport interface Frames<F extends AnyFunction = AnyFunction> {\n    next(...args: Parameters<F>): void;\n\n    cancel(): void;\n}\n\nexport const frames = <F extends AnyFunction>(fn: F): Frames<F> => {\n    let previousArgs: Parameters<F>;\n    let frameId = -1;\n    let lock = false;\n\n    return {\n        next: (...args: Parameters<F>): void => {\n            previousArgs = args;\n\n            if (!lock) {\n                lock = true;\n                frameId = requestAnimationFrame(() => {\n                    fn(...previousArgs);\n                    lock = false;\n                });\n            }\n        },\n        cancel: () => {\n            cancelAnimationFrame(frameId);\n            lock = false;\n        }\n    };\n};\n","export type Intersection = 'center' | 'cover' | 'touch'\n\n/**\n * Check if two DOM-Elements intersects each other.\n * @param a BoundingClientRect of the first element.\n * @param b BoundingClientRect of the second element.\n * @param mode Options are center, cover or touch.\n * @returns {boolean} If both elements intersects each other.\n */\nexport const intersects = (a: DOMRect, b: DOMRect, mode: Intersection = 'touch'): boolean => {\n    switch (mode) {\n        case 'center': {\n            const bxc = b.left + b.width / 2;\n            const byc = b.top + b.height / 2;\n\n            return bxc >= a.left &&\n                bxc <= a.right &&\n                byc >= a.top &&\n                byc <= a.bottom;\n        }\n        case 'cover': {\n            return b.left >= a.left &&\n                b.top >= a.top &&\n                b.right <= a.right &&\n                b.bottom <= a.bottom;\n        }\n        case 'touch': {\n            return a.right >= b.left &&\n                a.left <= b.right &&\n                a.bottom >= b.top &&\n                a.top <= b.bottom;\n        }\n    }\n};\n","// Determines if the device's primary input supports touch\n// See this article: https://css-tricks.com/touch-devices-not-judged-size/\nexport const isTouchDevice = (): boolean => matchMedia('(hover: none), (pointer: coarse)').matches;\n\n// Determines if the browser is safari\nexport const isSafariBrowser = (): boolean => 'safari' in window;\n","// Turns a value into an array if it's not already an array\nexport const arrayify = <T>(value: T | T[]): T[] => (Array.isArray(value) ? value : [value]);\n","/* eslint-disable @typescript-eslint/no-explicit-any */\nimport {arrayify} from './arrayify';\n\ntype Method = 'addEventListener' | 'removeEventListener';\ntype AnyFunction = (...arg: any) => any;\n\nconst eventListener = (method: Method) => (\n    items: (EventTarget | undefined) | (EventTarget | undefined)[],\n    events: string | string[],\n    fn: AnyFunction,\n    options = {}\n) => {\n\n    // Normalize array\n    if (items instanceof HTMLCollection || items instanceof NodeList) {\n        items = Array.from(items);\n    }\n\n    events = arrayify(events)\n    items = arrayify(items);\n\n    for (const el of items) {\n        if (el) {\n            for (const ev of events) {\n                el[method](ev, fn as EventListener, {capture: false, ...options});\n            }\n        }\n    }\n};\n\n/**\n * Add event(s) to element(s).\n * @param elements DOM-Elements\n * @param events Event names\n * @param fn Callback\n * @param options Optional options\n * @return Array passed arguments\n */\nexport const on = eventListener('addEventListener');\n\n/**\n * Remove event(s) from element(s).\n * @param elements DOM-Elements\n * @param events Event names\n * @param fn Callback\n * @param options Optional options\n * @return Array passed arguments\n */\nexport const off = eventListener('removeEventListener');\n\n/**\n * Simplifies a touch / mouse-event\n * @param evt\n */\nexport const simplifyEvent = (evt: any): {\n    target: HTMLElement;\n    x: number;\n    y: number;\n} => {\n    const {clientX, clientY, target} = evt.touches?.[0] ?? evt;\n    return {x: clientX, y: clientY, target};\n};\n","import {arrayify} from './arrayify';\n\nexport type SelectAllSelectors = (string | Element)[] | string | Element;\n\n/**\n * Takes a selector (or array of selectors) and returns the matched nodes.\n * @param selector The selector or an Array of selectors.\n * @param doc\n * @returns {Array} Array of DOM-Nodes.\n */\nexport const selectAll = (selector: SelectAllSelectors, doc: Document = document): Element[] =>\n    arrayify(selector)\n        .map(item =>\n            typeof item === 'string'\n                ? Array.from(doc.querySelectorAll(item))\n                : item instanceof Element\n                    ? item\n                    : null\n        )\n        .flat()\n        .filter(Boolean) as Element[];\n","\n// https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/button#value\nexport type MouseButton = 0  // Main\n    | 1  // Auxiliary\n    | 2  // Secondary\n    | 3  // Fourth\n    | 4; // Fifth\n\nexport type Modifier = 'ctrl'\n    | 'alt'\n    | 'shift';\n\nexport type Trigger = MouseButton | MouseButtonWithModifiers;\n\nexport type MouseButtonWithModifiers =  {\n    button: MouseButton,\n    modifiers: Modifier[]\n};\n\n/**\n * Determines whether a MouseEvent should execute until completion depending on\n * which button and modifier(s) are active for the MouseEvent.\n * The Event will execute to completion if ANY of the triggers \"matches\"\n * @param event MouseEvent that should be checked\n * @param triggers A list of Triggers that signify that the event should execute until completion\n * @returns Whether the MouseEvent should execute until completion\n */\nexport const matchesTrigger = (event: MouseEvent, triggers: Trigger[]): boolean =>\n    triggers.some((trigger) => {\n\n        // The trigger requires only a specific button to be pressed\n        if (typeof trigger === 'number') {\n            return event.button === trigger;\n        }\n\n        // The trigger requires a specific button to be pressed AND some modifiers\n        if (typeof trigger === 'object') {\n            if (trigger.button !== event.button) {\n                return false;\n            }\n\n            return trigger.modifiers.every((modifier) => {\n                switch (modifier) {\n                    case 'alt':\n                        return event.altKey;\n                    case 'ctrl':\n                        return event.ctrlKey || event.metaKey;\n                    case 'shift':\n                        return event.shiftKey;\n                }\n            });\n        }\n\n        return false;\n    });\n","import {EventTarget} from './EventEmitter';\nimport type {AreaLocation, Coordinates, ScrollEvent, SelectionEvents, SelectionOptions, SelectionStore} from './types';\nimport {PartialSelectionOptions} from './types';\nimport {css} from './utils/css';\nimport {domRect} from './utils/domRect';\nimport {Frames, frames} from './utils/frames';\nimport {intersects} from './utils/intersects';\nimport {isSafariBrowser, isTouchDevice} from './utils/browser';\nimport {on, off, simplifyEvent} from './utils/events';\nimport {selectAll, SelectAllSelectors} from './utils/selectAll';\nimport {matchesTrigger} from './utils/matchesTrigger';\n\n// Re-export types\nexport * from './types';\n\n// Some var shorting for better compression and readability\nconst {abs, max, min, ceil} = Math;\n\nconst makeSelectionStore = (stored: Element[] = []): SelectionStore => ({\n    stored,\n    selected: [],\n    touched: [],\n    changed: {added: [], removed: []}\n});\n\nexport default class SelectionArea extends EventTarget<SelectionEvents> {\n    public static version = VERSION;\n\n    // Options\n    private readonly _options: SelectionOptions;\n\n    // Selection store\n    private _selection: SelectionStore = makeSelectionStore();\n\n    // Area element and clipping element\n    private readonly _area: HTMLElement;\n    private readonly _clippingElement: HTMLElement;\n\n    // Target container (element) and boundary (cached)\n    private _targetElement?: Element;\n    private _targetBoundary?: Element;\n    private _targetBoundaryScrolled = true;\n    private _targetRect?: DOMRect;\n    private _selectables: Element[] = [];\n    private _latestElement?: Element;\n\n    // Dynamically constructed area rect\n    private _areaLocation: AreaLocation = {y1: 0, x2: 0, y2: 0, x1: 0};\n    private _areaRect = domRect();\n\n    // If a single click is being performed, it's a single-click until the user dragged the mouse\n    private _singleClick = true;\n    private _frame: Frames;\n\n    // Required data for scrolling\n    private _scrollAvailable = true;\n    private _scrollingActive = false;\n    private _scrollSpeed: Coordinates = {x: 0, y: 0};\n    private _scrollDelta: Coordinates = {x: 0, y: 0};\n\n    // Required for keydown scrolling\n    private _lastMousePosition = {x: 0, y: 0};\n\n    constructor(opt: PartialSelectionOptions) {\n        super();\n\n        this._options = {\n            selectionAreaClass: 'selection-area',\n            selectionContainerClass: undefined,\n            selectables: [],\n            document: window.document,\n            startAreas: ['html'],\n            boundaries: ['html'],\n            container: 'body',\n            ...opt,\n\n            behaviour: {\n                overlap: 'invert',\n                intersect: 'touch',\n                triggers: [0],\n                ...opt.behaviour,\n                startThreshold: opt.behaviour?.startThreshold ?\n                    typeof opt.behaviour.startThreshold === 'number' ?\n                        opt.behaviour.startThreshold :\n                        {x: 10, y: 10, ...opt.behaviour.startThreshold} : {x: 10, y: 10},\n                scrolling: {\n                    speedDivider: 10,\n                    manualSpeed: 750,\n                    ...opt.behaviour?.scrolling,\n                    startScrollMargins: {\n                        x: 0,\n                        y: 0,\n                        ...opt.behaviour?.scrolling?.startScrollMargins,\n                    }\n                }\n            },\n\n            features: {\n                range: true,\n                touch: true,\n                deselectOnBlur: false,\n                ...opt.features,\n                singleTap: {\n                    allow: true,\n                    intersect: 'native',\n                    ...opt.features?.singleTap,\n                }\n            }\n        };\n\n        // Bind locale functions to instance\n        /* eslint-disable @typescript-eslint/no-explicit-any */\n        for (const key of Object.getOwnPropertyNames(Object.getPrototypeOf(this))) {\n            if (typeof (this as any)[key] === 'function') {\n                (this as any)[key] = (this as any)[key].bind(this);\n            }\n        }\n\n        const {document, selectionAreaClass, selectionContainerClass} = this._options;\n        this._area = document.createElement('div');\n        this._clippingElement = document.createElement('div');\n        this._clippingElement.appendChild(this._area);\n\n        this._area.classList.add(selectionAreaClass);\n\n        if (selectionContainerClass) {\n            this._clippingElement.classList.add(selectionContainerClass);\n        }\n\n        css(this._area, {\n            willChange: 'top, left, bottom, right, width, height',\n            top: 0,\n            left: 0,\n            position: 'fixed'\n        });\n\n        css(this._clippingElement, {\n            overflow: 'hidden',\n            position: 'fixed',\n            transform: 'translate3d(0, 0, 0)', // https://stackoverflow.com/a/38268846\n            pointerEvents: 'none',\n            zIndex: '1'\n        });\n\n        this._frame = frames((evt: MouseEvent | TouchEvent) => {\n            this._recalculateSelectionAreaRect();\n            this._updateElementSelection();\n            this._emitEvent('move', evt);\n            this._redrawSelectionArea();\n        });\n\n        this.enable();\n    }\n\n    _toggleStartEvents(activate = true): void {\n        const {document, features} = this._options;\n        const fn = activate ? on : off;\n\n        fn(document, 'mousedown', this._onTapStart);\n\n        if (features.touch) {\n            fn(document, 'touchstart', this._onTapStart, {passive: false});\n        }\n    }\n\n    _onTapStart(evt: MouseEvent | TouchEvent, silent = false): void {\n        const {x, y, target} = simplifyEvent(evt);\n        const {document, startAreas, boundaries, features, behaviour} = this._options;\n        const targetBoundingClientRect = target.getBoundingClientRect();\n\n        if (evt instanceof MouseEvent && !matchesTrigger(evt, behaviour.triggers)) {\n            return;\n        }\n\n        // Find start-areas and boundaries\n        const resolvedStartAreas = selectAll(startAreas, document);\n        const resolvedBoundaries = selectAll(boundaries, document);\n\n        // Check in which container the user currently acts\n        this._targetElement = resolvedBoundaries.find(el =>\n            intersects(el.getBoundingClientRect(), targetBoundingClientRect)\n        );\n\n        // Check if the area starts in one of the start areas / boundaries\n        const evtPath = evt.composedPath();\n        const targetStartArea = resolvedStartAreas.find(el => evtPath.includes(el));\n        this._targetBoundary = resolvedBoundaries.find(el => evtPath.includes(el));\n\n        if (!this._targetElement || !targetStartArea || !this._targetBoundary) {\n            return;\n        }\n\n        if (!silent && this._emitEvent('beforestart', evt) === false) {\n            return;\n        }\n\n        this._areaLocation = {x1: x, y1: y, x2: 0, y2: 0};\n\n        // Lock scrolling in the target container\n        const scrollElement = document.scrollingElement ?? document.body;\n        this._scrollDelta = {x: scrollElement.scrollLeft, y: scrollElement.scrollTop};\n\n        // To detect single-click\n        this._singleClick = true;\n        this.clearSelection(false, true);\n\n        on(document, ['touchmove', 'mousemove'], this._delayedTapMove, {passive: false});\n        on(document, ['mouseup', 'touchcancel', 'touchend'], this._onTapStop);\n        on(document, 'scroll', this._onScroll);\n\n        if (features.deselectOnBlur) {\n            this._targetBoundaryScrolled = false;\n            on(this._targetBoundary, 'scroll', this._onStartAreaScroll);\n        }\n    }\n\n    _onSingleTap(evt: MouseEvent | TouchEvent): void {\n        const {singleTap: {intersect}, range} = this._options.features;\n        const e = simplifyEvent(evt);\n        let target;\n\n        if (intersect === 'native') {\n            target = e.target;\n        } else if (intersect === 'touch') {\n            this.resolveSelectables();\n\n            const {x, y} = e;\n            target = this._selectables.find(v => {\n                const {right, left, top, bottom} = v.getBoundingClientRect();\n                return x < right && x > left && y < bottom && y > top;\n            });\n        }\n\n        if (!target) {\n            return;\n        }\n\n        /**\n         * Resolve selectables again.\n         * If the user started in a scrollable area, they will be reduced\n         * to the current area. Prevent the exclusion of these if a range-selection\n         * gets performed.\n         */\n        this.resolveSelectables();\n\n        // Traverse dom upwards to check if the target is selectable\n        while (!this._selectables.includes(target)) {\n            if (target.parentElement) {\n                target = target.parentElement;\n            } else {\n                if (!this._targetBoundaryScrolled) {\n                    this.clearSelection();\n                }\n\n                return;\n            }\n\n        }\n\n        // Grab the current store first in case it gets set back\n        const {stored} = this._selection;\n        this._emitEvent('start', evt);\n\n        if (evt.shiftKey && range && this._latestElement) {\n            const reference = this._latestElement;\n\n            // Resolve the correct range\n            const [preceding, following] = reference.compareDocumentPosition(target) & 4 ?\n                [target, reference] : [reference, target];\n\n            const rangeItems = [...this._selectables.filter(el =>\n                (el.compareDocumentPosition(preceding) & 4) &&\n                (el.compareDocumentPosition(following) & 2)\n            ), preceding, following];\n\n            this.select(rangeItems);\n            this._latestElement = reference; // the latestElement is by default cleared in .select()\n        } else if (\n            stored.includes(target) && (\n                stored.length === 1 || evt.ctrlKey ||\n                stored.every(v => this._selection.stored.includes(v))\n            )\n        ) {\n            this.deselect(target);\n        } else {\n            this.select(target);\n            this._latestElement = target;\n        }\n    }\n\n    _delayedTapMove(evt: MouseEvent | TouchEvent): void {\n        const {container, document, behaviour: {startThreshold}} = this._options;\n        const {x1, y1} = this._areaLocation; // Coordinates of the first \"tap\"\n        const {x, y} = simplifyEvent(evt);\n\n        // Check the pixel threshold\n        if (\n\n            // Single number for both coordinates\n            (typeof startThreshold === 'number' && abs((x + y) - (x1 + y1)) >= startThreshold) ||\n\n            // Different x and y threshold\n            (typeof startThreshold === 'object' && abs(x - x1) >= (startThreshold as Coordinates).x || abs(y - y1) >= (startThreshold as Coordinates).y)\n        ) {\n            off(document, ['mousemove', 'touchmove'], this._delayedTapMove, {passive: false});\n\n            if (this._emitEvent('beforedrag', evt) === false) {\n                off(document, ['mouseup', 'touchcancel', 'touchend'], this._onTapStop);\n                return;\n            }\n\n            on(document, ['mousemove', 'touchmove'], this._onTapMove, {passive: false});\n\n            // Make area element visible\n            css(this._area, 'display', 'block');\n\n            // Append selection-area to the dom\n            selectAll(container, document)[0].appendChild(this._clippingElement);\n\n            this.resolveSelectables();\n\n            // An action is recognized as single-select until the user performed a multi-selection\n            this._singleClick = false;\n\n            // Just saving the boundaries of this container for later\n            this._targetRect = this._targetElement!.getBoundingClientRect();\n\n            // Find a container and check if it's scrollable\n            this._scrollAvailable =\n                this._targetElement!.scrollHeight !== this._targetElement!.clientHeight ||\n                this._targetElement!.scrollWidth !== this._targetElement!.clientWidth;\n\n            if (this._scrollAvailable) {\n\n                // Detect mouse scrolling\n                on(this._targetElement, 'wheel', this._wheelScroll, {passive: false});\n\n                // Detect keyboard scrolling\n                on(this._options.document, 'keydown', this._keyboardScroll, {passive: false});\n\n\n                /**\n                 * The selection-area will also cover another element\n                 * out of the current scrollable parent. So find all elements\n                 * that are in the current scrollable element. Now these are\n                 * the only selectables instead of all.\n                 */\n                this._selectables = this._selectables.filter(s => this._targetElement!.contains(s));\n            }\n\n            // Re-setup selection area and fire event\n            this._setupSelectionArea();\n            this._emitEvent('start', evt);\n            this._onTapMove(evt);\n        }\n\n        this._handleMoveEvent(evt);\n    }\n\n    _setupSelectionArea(): void {\n        const {_clippingElement, _targetElement, _area} = this;\n        const tr = this._targetRect = _targetElement!.getBoundingClientRect();\n\n        if (this._scrollAvailable) {\n\n            /**\n             * To clip the area, the selection area has a parent\n             * which has exactly the same dimensions as the scrollable element.\n             * Now if the area exceeds these boundaries, it will be cropped.\n             */\n            css(_clippingElement, {\n                top: tr.top,\n                left: tr.left,\n                width: tr.width,\n                height: tr.height\n            });\n\n            /**\n             * The area element is relative to the clipping element,\n             * but when this is moved or transformed, we need to correct\n             * the positions via a negative margin.\n             */\n            css(_area, {\n                marginTop: -tr.top,\n                marginLeft: -tr.left\n            });\n        } else {\n\n            // \"Reset\" styles\n            css(_clippingElement, {\n                top: 0,\n                left: 0,\n                width: '100%',\n                height: '100%'\n            });\n\n            css(_area, {\n                marginTop: 0,\n                marginLeft: 0\n            });\n        }\n    }\n\n    _onTapMove(evt: MouseEvent | TouchEvent): void {\n        const {_scrollSpeed, _areaLocation, _options, _frame} = this;\n        const {speedDivider} = _options.behaviour.scrolling;\n        const _targetElement = this._targetElement as Element;\n\n        const {x, y} = simplifyEvent(evt);\n        _areaLocation.x2 = x;\n        _areaLocation.y2 = y;\n\n        this._lastMousePosition.x = x;\n        this._lastMousePosition.y = y;\n\n        if (this._scrollAvailable && !this._scrollingActive && (_scrollSpeed.y || _scrollSpeed.x)) {\n\n            // Continuous scrolling\n            this._scrollingActive = true;\n\n            const scroll = () => {\n                if (!_scrollSpeed.x && !_scrollSpeed.y) {\n                    this._scrollingActive = false;\n                    return;\n                }\n\n                // Reduce velocity, use ceil in both directions to scroll at least 1px per frame\n                const {scrollTop, scrollLeft} = _targetElement;\n\n                if (_scrollSpeed.y) {\n                    _targetElement.scrollTop += ceil(_scrollSpeed.y / speedDivider);\n                    _areaLocation.y1 -= _targetElement.scrollTop - scrollTop;\n                }\n\n                if (_scrollSpeed.x) {\n                    _targetElement.scrollLeft += ceil(_scrollSpeed.x / speedDivider);\n                    _areaLocation.x1 -= _targetElement.scrollLeft - scrollLeft;\n                }\n\n                /**\n                 * We changed the start coordinates -> redraw the selection-area\n                 * We changed the dimensions of the area element -> re-calc selected elements\n                 * The selected elements array has been changed -> fire event\n                 */\n                _frame.next(evt);\n\n                // Keep scrolling even if the user stops to move his pointer\n                requestAnimationFrame(scroll);\n            };\n\n            requestAnimationFrame(scroll);\n        } else {\n\n            /**\n             * Perform redrawing only if scrolling is not active.\n             * If scrolling is active, this area is getting re-dragged by the\n             * anonymize scroll function.\n             */\n            _frame.next(evt);\n        }\n\n        this._handleMoveEvent(evt);\n    }\n\n    _handleMoveEvent(evt: MouseEvent | TouchEvent) {\n        const {features} = this._options;\n\n        /**\n         * - Prevent auto-refresh for when pulling down on touch devices.\n         * - Prevent auto-scroll by the browser when on safari, and scrolling is handled by this library.\n         */\n        if ((features.touch && isTouchDevice()) || (this._scrollAvailable && isSafariBrowser())) {\n            evt.preventDefault(); // Prevent swipe-down refresh\n        }\n    }\n\n    _onScroll(): void {\n        const {_scrollDelta, _options: {document}} = this;\n        const {scrollTop, scrollLeft} = document.scrollingElement ?? document.body;\n\n        // Adjust area start location\n        this._areaLocation.x1 += _scrollDelta.x - scrollLeft;\n        this._areaLocation.y1 += _scrollDelta.y - scrollTop;\n        _scrollDelta.x = scrollLeft;\n        _scrollDelta.y = scrollTop;\n\n        // The area needs to be set back as the target-container has changed in its position\n        this._setupSelectionArea();\n        this._frame.next(null);\n    }\n\n    _onStartAreaScroll(): void {\n        this._targetBoundaryScrolled = true;\n        off(this._targetElement, 'scroll', this._onStartAreaScroll);\n    }\n\n    _wheelScroll(evt: ScrollEvent): void {\n        const {manualSpeed} = this._options.behaviour.scrolling;\n\n        // Consistent scrolling speed on all browsers\n        const deltaY = evt.deltaY ? (evt.deltaY > 0 ? 1 : -1) : 0;\n        const deltaX = evt.deltaX ? (evt.deltaX > 0 ? 1 : -1) : 0;\n        this._scrollSpeed.y += deltaY * manualSpeed;\n        this._scrollSpeed.x += deltaX * manualSpeed;\n        this._onTapMove(evt);\n\n        // Prevent default scrolling behavior, e.g. page scrolling\n        evt.preventDefault();\n    }\n\n    _keyboardScroll(evt: KeyboardEvent): void {\n        const {manualSpeed} = this._options.behaviour.scrolling;\n\n        const deltaX = evt.key === 'ArrowLeft' ? -1 : evt.key === 'ArrowRight' ? 1 : 0;\n        const deltaY = evt.key === 'ArrowUp' ? -1 : evt.key === 'ArrowDown' ? 1 : 0;\n\n        this._scrollSpeed.x += Math.sign(deltaX) * manualSpeed;\n        this._scrollSpeed.y += Math.sign(deltaY) * manualSpeed;\n\n        evt.preventDefault();\n\n        this._onTapMove({\n            clientX: this._lastMousePosition.x,\n            clientY: this._lastMousePosition.y,\n            preventDefault: () => void 0,\n        } as ScrollEvent);\n    }\n\n    _recalculateSelectionAreaRect(): void {\n        const {_scrollSpeed, _areaLocation, _targetElement, _options} = this;\n        const {scrollTop, scrollHeight, clientHeight, scrollLeft, scrollWidth, clientWidth} = _targetElement as Element;\n        const _targetRect = this._targetRect as DOMRect;\n\n        const {x1, y1} = _areaLocation;\n        let {x2, y2} = _areaLocation;\n\n        const {behaviour: {scrolling: {startScrollMargins}}} = _options;\n\n        if (x2 < _targetRect.left + startScrollMargins.x) {\n            _scrollSpeed.x = scrollLeft ? -abs(_targetRect.left - x2 + startScrollMargins.x) : 0;\n            x2 = x2 < _targetRect.left ? _targetRect.left : x2;\n        } else if (x2 > _targetRect.right - startScrollMargins.x) {\n            _scrollSpeed.x = scrollWidth - scrollLeft - clientWidth ? abs(_targetRect.left + _targetRect.width - x2 - startScrollMargins.x) : 0;\n            x2 = x2 > _targetRect.right ? _targetRect.right : x2;\n        } else {\n            _scrollSpeed.x = 0;\n        }\n\n        if (y2 < _targetRect.top + startScrollMargins.y) {\n            _scrollSpeed.y = scrollTop ? -abs(_targetRect.top - y2 + startScrollMargins.y) : 0;\n            y2 = y2 < _targetRect.top ? _targetRect.top : y2;\n        } else if (y2 > _targetRect.bottom - startScrollMargins.y) {\n            _scrollSpeed.y = scrollHeight - scrollTop - clientHeight ? abs(_targetRect.top + _targetRect.height - y2 - startScrollMargins.y) : 0;\n            y2 = y2 > _targetRect.bottom ? _targetRect.bottom : y2;\n        } else {\n            _scrollSpeed.y = 0;\n        }\n\n        const x3 = min(x1, x2);\n        const y3 = min(y1, y2);\n        const x4 = max(x1, x2);\n        const y4 = max(y1, y2);\n\n        this._areaRect = domRect(x3, y3, x4 - x3, y4 - y3);\n    }\n\n    _redrawSelectionArea(): void {\n        const {x, y, width, height} = this._areaRect;\n        const {style} = this._area;\n\n        // Using transform will make the area's borders look blurry\n        style.left = `${x}px`;\n        style.top = `${y}px`;\n        style.width = `${width}px`;\n        style.height = `${height}px`;\n    }\n\n    _onTapStop(evt: MouseEvent | TouchEvent | null, silent: boolean): void {\n        const {document, features} = this._options;\n        const {_singleClick} = this;\n\n        // Remove event handlers\n        off(this._targetElement, 'scroll', this._onStartAreaScroll);\n        off(document, ['mousemove', 'touchmove'], this._delayedTapMove);\n        off(document, ['touchmove', 'mousemove'], this._onTapMove);\n        off(document, ['mouseup', 'touchcancel', 'touchend'], this._onTapStop);\n        off(document, 'scroll', this._onScroll);\n\n        // Keep selection until the next time\n        this._keepSelection();\n\n        if (evt && _singleClick && features.singleTap.allow) {\n            this._onSingleTap(evt);\n        } else if (!_singleClick && !silent) {\n            this._updateElementSelection();\n            this._emitEvent('stop', evt);\n        }\n\n        this._scrollSpeed.x = 0;\n        this._scrollSpeed.y = 0;\n\n        // Unbind mouse scrolling listener\n        off(this._targetElement, 'wheel', this._wheelScroll, {passive: true});\n\n        // Unbind keyboard scrolling listener\n        off(this._options.document, 'keydown', this._keyboardScroll, {passive: true,});\n\n        // Remove selection-area from dom\n        this._clippingElement.remove();\n\n        // Cancel current frame\n        this._frame?.cancel();\n\n        // Hide selection area\n        css(this._area, 'display', 'none');\n    }\n\n    _updateElementSelection(): void {\n        const {_selectables, _options, _selection, _areaRect} = this;\n        const {stored, selected, touched} = _selection;\n        const {intersect, overlap} = _options.behaviour;\n\n        const invert = overlap === 'invert';\n        const newlyTouched: Element[] = [];\n        const added: Element[] = [];\n        const removed: Element[] = [];\n\n        // Find newly selected elements\n        for (let i = 0; i < _selectables.length; i++) {\n            const node = _selectables[i];\n\n            // Check if the area intersects an element\n            if (intersects(_areaRect, node.getBoundingClientRect(), intersect)) {\n\n                // Check if the element wasn't present in the last selection.\n                if (!selected.includes(node)) {\n\n                    // Check if the user wants to invert the selection for already selected elements\n                    if (invert && stored.includes(node)) {\n                        removed.push(node);\n                        continue;\n                    } else {\n                        added.push(node);\n                    }\n                } else if (stored.includes(node) && !touched.includes(node)) {\n                    touched.push(node);\n                }\n\n                newlyTouched.push(node);\n            }\n        }\n\n        // Re-select elements which were previously stored\n        if (invert) {\n            added.push(...stored.filter(v => !selected.includes(v)));\n        }\n\n        // Check which elements where removed since last selection\n        const keep = overlap === 'keep';\n        for (let i = 0; i < selected.length; i++) {\n            const node = selected[i];\n\n            if (!newlyTouched.includes(node) && !(\n\n                // Check if the user wants to keep previously selected elements, e.g.,\n                // not make them part of the current selection as soon as they're touched.\n                keep && stored.includes(node)\n            )) {\n                removed.push(node);\n            }\n        }\n\n        _selection.selected = newlyTouched;\n        _selection.changed = {added, removed};\n\n        // Prevent range selection when selection an area.\n        this._latestElement = undefined;\n    }\n\n    _emitEvent(name: keyof SelectionEvents, evt: MouseEvent | TouchEvent | null): unknown {\n        return this.emit(name, {\n            event: evt,\n            store: this._selection,\n            selection: this\n        });\n    }\n\n    _keepSelection(): void {\n        const {_options, _selection} = this;\n        const {selected, changed, touched, stored} = _selection;\n        const addedElements = selected.filter(el => !stored.includes(el));\n\n        switch (_options.behaviour.overlap) {\n            case 'drop': {\n                _selection.stored = [\n                    ...addedElements,\n                    ...stored.filter(el => !touched.includes(el))  // Elements not touched\n                ];\n                break;\n            }\n            case 'invert': {\n                _selection.stored = [\n                    ...addedElements,\n                    ...stored.filter(el => !changed.removed.includes(el))  // Elements not removed from selection\n                ];\n                break;\n            }\n            case 'keep': {\n                _selection.stored = [\n                    ...stored,\n                    ...selected.filter(el => !stored.includes(el)) // Newly added\n                ];\n                break;\n            }\n        }\n    }\n\n    /**\n     * Manually triggers the start of a selection\n     * @param evt A MouseEvent / TouchEvent-like object\n     * @param silent If beforestart should be fired\n     */\n    trigger(evt: MouseEvent | TouchEvent, silent = true): void {\n        this._onTapStart(evt, silent);\n    }\n\n    /**\n     * Can be used if during a selection elements have been added\n     * Will update everything that can be selected\n     */\n    resolveSelectables(): void {\n        this._selectables = selectAll(this._options.selectables, this._options.document);\n    }\n\n    /**\n     * Same as deselecting, but for all elements currently selected\n     * @param includeStored If the store should also get cleared\n     * @param quiet If move / stop events should be fired\n     */\n    clearSelection(includeStored = true, quiet = false): void {\n        const {selected, stored, changed} = this._selection;\n\n        changed.added = [];\n        changed.removed.push(\n            ...selected,\n            ...(includeStored ? stored : [])\n        );\n\n        // Fire event\n        if (!quiet) {\n            this._emitEvent('move', null);\n            this._emitEvent('stop', null);\n        }\n\n        // Reset state\n        this._selection = makeSelectionStore(includeStored ? [] : stored);\n    }\n\n    /**\n     * @returns {Array} Selected elements\n     */\n    getSelection(): Element[] {\n        return this._selection.stored;\n    }\n\n    /**\n     * @returns {HTMLElement} The selection area element\n     */\n    getSelectionArea(): HTMLElement {\n        return this._area;\n    }\n\n    /**\n     * @returns {Element[]} Available selectable elements for current selection\n     */\n    getSelectables(): Element[] {\n        return this._selectables;\n    }\n\n    /**\n     * Set the location of the selection area\n     * @param location A partial AreaLocation object\n     */\n    setAreaLocation(location: Partial<AreaLocation>) {\n        Object.assign(this._areaLocation, location);\n        this._redrawSelectionArea();\n    }\n\n    /**\n     * @returns {AreaLocation} The current location of the selection area\n     */\n    getAreaLocation(): AreaLocation {\n        return this._areaLocation;\n    }\n\n    /**\n     * Cancel the current selection process, pass true to fire a stop event after cancel\n     * @param keepEvent If a stop event should be fired\n     */\n    cancel(keepEvent = false): void {\n        this._onTapStop(null, !keepEvent);\n    }\n\n    /**\n     * Unbinds all events and removes the area-element.\n     */\n    destroy(): void {\n        this.cancel();\n        this.disable();\n        this._clippingElement.remove();\n        super.unbindAllListeners();\n    }\n\n    /**\n     * Enable selecting elements\n     */\n    enable = this._toggleStartEvents;\n\n    /**\n     * Disable selecting elements\n     */\n    disable = this._toggleStartEvents.bind(this, false);\n\n    /**\n     * Adds elements to the selection\n     * @param query CSS Query, can be an array of queries\n     * @param quiet If this should not trigger the move event\n     */\n    select(query: SelectAllSelectors, quiet = false): Element[] {\n        const {changed, selected, stored} = this._selection;\n        const elements = selectAll(query, this._options.document).filter(el =>\n            !selected.includes(el) &&\n            !stored.includes(el)\n        );\n\n        // Update element lists\n        stored.push(...elements);\n        selected.push(...elements);\n        changed.added.push(...elements);\n        changed.removed = [];\n\n        // We don't know which element was \"selected\" first, so clear it\n        this._latestElement = undefined;\n\n        // Fire event\n        if (!quiet) {\n            this._emitEvent('move', null);\n            this._emitEvent('stop', null);\n        }\n\n        return elements;\n    }\n\n    /**\n     * Removes a particular element from the selection\n     * @param query CSS Query, can be an array of queries\n     * @param quiet If this should not trigger the move event\n     */\n    deselect(query: SelectAllSelectors, quiet = false) {\n        const {selected, stored, changed} = this._selection;\n\n        const elements = selectAll(query, this._options.document).filter(el =>\n            selected.includes(el) ||\n            stored.includes(el)\n        );\n\n        this._selection.stored = stored.filter(el => !elements.includes(el));\n        this._selection.selected = selected.filter(el => !elements.includes(el));\n        this._selection.changed.added = [];\n        this._selection.changed.removed.push(\n            ...elements.filter(el => !changed.removed.includes(el))\n        );\n\n        // We don't know which element was \"selected\" first, so clear it\n        this._latestElement = undefined;\n\n        // Fire event\n        if (!quiet) {\n            this._emitEvent('move', null);\n            this._emitEvent('stop', null);\n        }\n    }\n}\n"],"names":["EventTarget","event","cb","set","_a","data","ok","unitify","val","unit","css","style","attr","key","value","domRect","x","y","width","height","rect","frames","fn","previousArgs","frameId","lock","args","intersects","a","b","mode","bxc","byc","isTouchDevice","isSafariBrowser","arrayify","eventListener","method","items","events","options","el","ev","on","off","simplifyEvent","evt","clientX","clientY","target","selectAll","selector","doc","item","matchesTrigger","triggers","trigger","modifier","abs","max","min","ceil","makeSelectionStore","stored","_SelectionArea","opt","_b","_d","_c","_e","document","selectionAreaClass","selectionContainerClass","activate","features","silent","startAreas","boundaries","behaviour","targetBoundingClientRect","resolvedStartAreas","resolvedBoundaries","evtPath","targetStartArea","scrollElement","intersect","range","e","v","right","left","top","bottom","reference","preceding","following","rangeItems","container","startThreshold","x1","y1","s","_clippingElement","_targetElement","_area","tr","_scrollSpeed","_areaLocation","_options","_frame","speedDivider","scroll","scrollTop","scrollLeft","_scrollDelta","manualSpeed","deltaY","deltaX","scrollHeight","clientHeight","scrollWidth","clientWidth","_targetRect","x2","y2","startScrollMargins","x3","y3","x4","y4","_singleClick","_selectables","_selection","_areaRect","selected","touched","overlap","invert","newlyTouched","added","removed","i","node","keep","name","changed","addedElements","includeStored","quiet","location","keepEvent","query","elements","SelectionArea"],"mappings":"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"}