{"version":3,"file":"viselect.umd.js","sources":["../src/EventEmitter.ts","../src/utils/css.ts","../src/utils/events.ts","../src/utils/intersects.ts","../src/utils/selectAll.ts","../src/utils/constants.ts","../src/utils/frames.ts","../src/utils/shouldTrigger.ts","../src/index.ts"],"sourcesContent":["\n/* eslint-disable @typescript-eslint/no-explicit-any */\ntype AnyFunction = (...args: any[]) => any;\ntype EventMap = Record<string, AnyFunction>;\n\nexport class EventTarget<Events extends EventMap> {\n    private readonly _listeners = new Map<keyof Events, Set<AnyFunction>>();\n\n    public addEventListener<K extends keyof Events>(event: K, cb: Events[K]): this {\n        const set = this._listeners.get(event) ?? new Set();\n        this._listeners.set(event, set);\n        set.add(cb as AnyFunction);\n        return this;\n    }\n\n    public removeEventListener<K extends keyof Events>(event: K, cb: Events[K]): this {\n        this._listeners.get(event)?.delete(cb as AnyFunction);\n        return this;\n    }\n\n    public dispatchEvent<K extends keyof Events>(event: K, ...data: Parameters<Events[K]>): unknown {\n        let ok = true;\n        for (const cb of (this._listeners.get(event) ?? [])) {\n            ok = (cb(...data) !== false) && ok;\n        }\n\n        return ok;\n    }\n\n    public unbindAllListeners(): void {\n        this._listeners.clear();\n    }\n\n    // Let's also support on, off and emit like node\n    /* eslint-disable no-invalid-this */\n    public on = this.addEventListener;\n    public off = this.removeEventListener;\n    public emit = this.dispatchEvent;\n}\n","const unitify = (val: string | number, unit = 'px'): string => {\n    return typeof val === 'number' ? val + unit : val;\n};\n\n/**\n * Add css to a DOM-Element or returns the current\n * value of a property.\n *\n * @param el The Element.\n * @param attr The attribute or an object which holds css key-properties.\n * @param val The value for a single attribute.\n * @returns {*}\n */\nexport function css(\n    {style}: HTMLElement,\n    attr: Partial<Record<keyof CSSStyleDeclaration, string | number>> | string,\n    val?: string | number\n): void {\n    if (typeof attr === 'object') {\n\n        for (const [key, value] of Object.entries(attr)) {\n            value !== undefined && (style[key as any] = unitify(value));\n        }\n\n    } else if (val !== undefined) {\n        style[attr as any] = unitify(val);\n    }\n}\n\n\n","/* eslint-disable @typescript-eslint/explicit-module-boundary-types */\n/* eslint-disable @typescript-eslint/no-explicit-any */\ntype Method = 'addEventListener' | 'removeEventListener';\ntype AnyFunction = (...arg: any) => any;\n\nexport type EventBindingArgs = [\n    (EventTarget | undefined) | (EventTarget | undefined)[],\n    string | string[],\n    AnyFunction,\n    Record<string, unknown>?\n];\n\n/* eslint-disable prefer-rest-params */\nconst eventListener = (method: Method) => (\n    items: (EventTarget | undefined) | (EventTarget | undefined)[],\n    events: string | string[],\n    fn: AnyFunction, options = {}\n): EventBindingArgs => {\n\n    // Normalize array\n    if (items instanceof HTMLCollection || items instanceof NodeList) {\n        items = Array.from(items);\n    } else if (!Array.isArray(items)) {\n        items = [items];\n    }\n\n    if (!Array.isArray(events)) {\n        events = [events];\n    }\n\n    for (const el of items) {\n        if (el) {\n            for (const ev of events) {\n                el[method](ev, fn as EventListener, {capture: false, ...options});\n            }\n        }\n    }\n\n    return [items, events, fn, options];\n};\n\n/**\n * Add event(s) to element(s).\n * @param elements DOM-Elements\n * @param events Event names\n * @param fn Callback\n * @param options Optional options\n * @return Array passed arguments\n */\nexport const on = eventListener('addEventListener');\n\n/**\n * Remove event(s) from element(s).\n * @param elements DOM-Elements\n * @param events Event names\n * @param fn Callback\n * @param options Optional options\n * @return Array passed arguments\n */\nexport const off = eventListener('removeEventListener');\n\n/**\n * Simplifies a touch / mouse-event\n * @param evt\n */\nexport const simplifyEvent = (evt: any): {\n    target: HTMLElement;\n    x: number;\n    y: number;\n} => {\n    const {clientX, clientY, target} = evt.touches?.[0] ?? evt;\n    return {x: clientX, y: clientY, target};\n};\n","export type Intersection = 'center' | 'cover' | 'touch'\n\n/**\n * Check if two DOM-Elements intersects each other.\n * @param a BoundingClientRect of the first element.\n * @param b BoundingClientRect of the second element.\n * @param mode Options are center, cover or touch.\n * @returns {boolean} If both elements intersects each other.\n */\nexport function intersects(a: DOMRect, b: DOMRect, mode: Intersection = 'touch'): boolean {\n    switch (mode) {\n        case 'center': {\n            const bxc = b.left + b.width / 2;\n            const byc = b.top + b.height / 2;\n\n            return bxc >= a.left &&\n                bxc <= a.right &&\n                byc >= a.top &&\n                byc <= a.bottom;\n        }\n        case 'cover': {\n            return b.left >= a.left &&\n                b.top >= a.top &&\n                b.right <= a.right &&\n                b.bottom <= a.bottom;\n        }\n        case 'touch': {\n            return a.right >= b.left &&\n                a.left <= b.right &&\n                a.bottom >= b.top &&\n                a.top <= b.bottom;\n        }\n    }\n}\n","export type SelectAllSelectors = readonly (string | Element)[] | string | Element;\n\n/**\n * Takes a selector (or array of selectors) and returns the matched nodes.\n * @param selector The selector or an Array of selectors.\n * @param doc\n * @returns {Array} Array of DOM-Nodes.\n */\nexport function selectAll(selector: SelectAllSelectors, doc: Document = document): Element[] {\n    const list = !Array.isArray(selector) ? [selector] : selector;\n    let nodes: Element[] = [];\n\n    for (let i = 0, l = list.length; i < l; i++) {\n        const item = list[i];\n\n        if (typeof item === 'string') {\n            /**\n             * We can't use the spread operator here as with large amounts of elements\n             * we'll get a \"Maximum call stack size exceeded\"-error.\n             */\n            nodes = nodes.concat(Array.from(doc.querySelectorAll(item)));\n        } else if (item instanceof Element) {\n            nodes.push(item);\n        }\n    }\n\n    return nodes;\n}\n","// Determines if the device's primary input supports touch\n// See this article: https://css-tricks.com/touch-devices-not-judged-size/\nexport const isTouchDevice = (): boolean => matchMedia('(hover: none), (pointer: coarse)').matches;\n\n// Determines if the browser is safari\nexport const isSafariBrowser = (): boolean => 'safari' in window;\n","/* eslint-disable @typescript-eslint/no-explicit-any */\ntype AnyFunction = (...args: any[]) => void;\n\nexport interface Frames<F extends AnyFunction = AnyFunction> {\n    next(...args: Parameters<F>): void;\n\n    cancel(): void;\n}\n\nexport const frames = <F extends AnyFunction>(fn: F): Frames<F> => {\n    let previousArgs: Parameters<F>;\n    let frameId = -1;\n    let lock = false;\n\n    return {\n        next(...args: Parameters<F>): void {\n            previousArgs = args;\n\n            if (!lock) {\n                lock = true;\n                frameId = requestAnimationFrame(() => {\n                    fn(...previousArgs);\n                    lock = false;\n                });\n            }\n        },\n        cancel() {\n            cancelAnimationFrame(frameId);\n            lock = false;\n        }\n    };\n};\n","import {Trigger} from \"../types\";\n\n/**\n * Determines whether a MouseEvent should execute until completion depending on\n * which button and modifier(s) are active for the MouseEvent.\n * The Event will execute to completion if ANY of the triggers \"matches\"\n * @param event MouseEvent that should be checked\n * @param triggers A list of Triggers that signify that the event should execute until completion\n * @returns Whether the MouseEvent should execute until completion\n */\nexport function shouldTrigger(event: MouseEvent, triggers: Trigger[]): boolean {\n    for (const trigger of triggers) {\n        // The trigger requires only a specific button to be pressed\n        if (typeof trigger === \"number\") {\n            return event.button === trigger;\n        }\n\n        // The trigger requires a specific button to be pressed AND some modifiers\n        if (typeof trigger === \"object\") {\n            const reqButtonIsPressed = trigger.button === event.button;\n\n            const allReqModifiersArePressed = trigger.modifiers.every((modifier) => {\n                switch (modifier) {\n                    case \"alt\":\n                        return event.altKey;\n                    case \"ctrl\":\n                        return event.ctrlKey || event.metaKey;\n                    case \"shift\":\n                        return event.shiftKey;\n                }\n            });\n\n            return reqButtonIsPressed && allReqModifiersArePressed;\n        }\n    }\n\n    // By default, we do not process the event\n    return false;\n}","import {EventTarget} from './EventEmitter';\nimport type {AreaLocation, Coordinates, ScrollEvent, SelectionEvents, SelectionOptions, SelectionStore} from './types';\nimport {PartialSelectionOptions} from './types';\nimport {css, frames, Frames, intersects, isSafariBrowser, isTouchDevice, off, on, selectAll, SelectAllSelectors, simplifyEvent, shouldTrigger} from './utils';\n\n// Re-export types\nexport * from './types';\n\n// Some var shorting for better compression and readability\nconst {abs, max, min, ceil} = Math;\n\nconst makeSelectionStore = (stored: Element[] = []): SelectionStore => ({\n    stored,\n    selected: [],\n    touched: [],\n    changed: {added: [], removed: []}\n});\n\nexport default class SelectionArea extends EventTarget<SelectionEvents> {\n    public static version = VERSION;\n\n    // Options\n    private readonly _options: SelectionOptions;\n\n    // Selection store\n    private _selection: SelectionStore = makeSelectionStore();\n\n    // Area element and clipping element\n    private readonly _area: HTMLElement;\n    private readonly _clippingElement: HTMLElement;\n\n    // Target container (element) and boundary (cached)\n    private _targetElement?: Element;\n    private _targetBoundary?: Element;\n    private _targetBoundaryScrolled = true;\n    private _targetRect?: DOMRect;\n    private _selectables: Element[] = [];\n    private _latestElement?: Element;\n\n    // Dynamically constructed area rect\n    private _areaLocation: AreaLocation = {y1: 0, x2: 0, y2: 0, x1: 0};\n    private _areaRect = new DOMRect();\n\n    // If a single click is being performed, it's a single-click until the user dragged the mouse\n    private _singleClick = true;\n    private _frame: Frames;\n\n    // Required data for scrolling\n    private _scrollAvailable = true;\n    private _scrollingActive = false;\n    private _scrollSpeed: Coordinates = {x: 0, y: 0};\n    private _scrollDelta: Coordinates = {x: 0, y: 0};\n\n    constructor(opt: PartialSelectionOptions) {\n        super();\n\n        this._options = {\n            selectionAreaClass: 'selection-area',\n            selectionContainerClass: undefined,\n            selectables: [],\n            document: window.document,\n            startAreas: ['html'],\n            boundaries: ['html'],\n            container: 'body',\n            ...opt,\n\n            behaviour: {\n                overlap: 'invert',\n                intersect: 'touch',\n                triggers: [0],\n                ...opt.behaviour,\n                startThreshold: opt.behaviour?.startThreshold ?\n                    typeof opt.behaviour.startThreshold === 'number' ?\n                        opt.behaviour.startThreshold :\n                        {x: 10, y: 10, ...opt.behaviour.startThreshold} : {x: 10, y: 10},\n                scrolling: {\n                    speedDivider: 10,\n                    manualSpeed: 750,\n                    ...opt.behaviour?.scrolling,\n                    startScrollMargins: {\n                        x: 0,\n                        y: 0,\n                        ...opt.behaviour?.scrolling?.startScrollMargins,\n                    }\n                }\n            },\n\n            features: {\n                range: true,\n                touch: true,\n                deselectOnBlur: false,\n                ...opt.features,\n                singleTap: {\n                    allow: true,\n                    intersect: 'native',\n                    ...opt.features?.singleTap,\n                }\n            }\n        };\n\n        // Bind locale functions to instance\n        /* eslint-disable @typescript-eslint/no-explicit-any */\n        for (const key of Object.getOwnPropertyNames(Object.getPrototypeOf(this))) {\n            if (typeof (this as any)[key] === 'function') {\n                (this as any)[key] = (this as any)[key].bind(this);\n            }\n        }\n\n        const {document, selectionAreaClass, selectionContainerClass} = this._options;\n        this._area = document.createElement('div');\n        this._clippingElement = document.createElement('div');\n        this._clippingElement.appendChild(this._area);\n\n        this._area.classList.add(selectionAreaClass);\n\n        if (selectionContainerClass) {\n            this._clippingElement.classList.add(selectionContainerClass);\n        }\n\n        css(this._area, {\n            willChange: 'top, left, bottom, right, width, height',\n            top: 0,\n            left: 0,\n            position: 'fixed'\n        });\n\n        css(this._clippingElement, {\n            overflow: 'hidden',\n            position: 'fixed',\n            transform: 'translate3d(0, 0, 0)', // https://stackoverflow.com/a/38268846\n            pointerEvents: 'none',\n            zIndex: '1'\n        });\n\n        this._frame = frames((evt: MouseEvent | TouchEvent) => {\n            this._recalculateSelectionAreaRect();\n            this._updateElementSelection();\n            this._emitEvent('move', evt);\n            this._redrawSelectionArea();\n        });\n\n        this.enable();\n    }\n\n    _toggleStartEvents(activate = true): void {\n        const {document, features} = this._options;\n        const fn = activate ? on : off;\n\n        fn(document, 'mousedown', this._onTapStart);\n\n        if (features.touch) {\n            fn(document, 'touchstart', this._onTapStart, {passive: false});\n        }\n    }\n\n    _onTapStart(evt: MouseEvent | TouchEvent, silent = false): void {\n        const {x, y, target} = simplifyEvent(evt);\n        const {document, startAreas, boundaries, features, behaviour} = this._options;\n        const targetBoundingClientRect = target.getBoundingClientRect();\n\n        if (evt instanceof MouseEvent && !shouldTrigger(evt, behaviour.triggers)) {\n            return;\n        }\n\n        // Find start-areas and boundaries\n        const resolvedStartAreas = selectAll(startAreas, document);\n        const resolvedBoundaries = selectAll(boundaries, document);\n\n        // Check in which container the user currently acts\n        this._targetElement = resolvedBoundaries.find(el =>\n            intersects(el.getBoundingClientRect(), targetBoundingClientRect)\n        );\n\n        // Check if the area starts in one of the start areas / boundaries\n        const evtPath = evt.composedPath();\n        const targetStartArea = resolvedStartAreas.find(el => evtPath.includes(el));\n        this._targetBoundary = resolvedBoundaries.find(el => evtPath.includes(el));\n\n        if (!this._targetElement || !targetStartArea || !this._targetBoundary) {\n            return;\n        }\n\n        if (!silent && this._emitEvent('beforestart', evt) === false) {\n            return;\n        }\n\n        this._areaLocation = {x1: x, y1: y, x2: 0, y2: 0};\n\n        // Lock scrolling in the target container\n        const scrollElement = document.scrollingElement ?? document.body;\n        this._scrollDelta = {x: scrollElement.scrollLeft, y: scrollElement.scrollTop};\n\n        // To detect single-click\n        this._singleClick = true;\n        this.clearSelection(false, true);\n\n        on(document, ['touchmove', 'mousemove'], this._delayedTapMove, {passive: false});\n        on(document, ['mouseup', 'touchcancel', 'touchend'], this._onTapStop);\n        on(document, 'scroll', this._onScroll);\n\n        if (features.deselectOnBlur) {\n            this._targetBoundaryScrolled = false;\n            on(this._targetBoundary, 'scroll', this._onStartAreaScroll);\n        }\n    }\n\n    _onSingleTap(evt: MouseEvent | TouchEvent): void {\n        const {singleTap: {intersect}, range} = this._options.features;\n        const e = simplifyEvent(evt);\n        let target;\n\n        if (intersect === 'native') {\n            target = e.target;\n        } else if (intersect === 'touch') {\n            this.resolveSelectables();\n\n            const {x, y} = e;\n            target = this._selectables.find(v => {\n                const {right, left, top, bottom} = v.getBoundingClientRect();\n                return x < right && x > left && y < bottom && y > top;\n            });\n        }\n\n        if (!target) {\n            return;\n        }\n\n        /**\n         * Resolve selectables again.\n         * If the user started in a scrollable area, they will be reduced\n         * to the current area. Prevent the exclusion of these if a range-selection\n         * gets performed.\n         */\n        this.resolveSelectables();\n\n        // Traverse dom upwards to check if the target is selectable\n        while (!this._selectables.includes(target)) {\n            if (target.parentElement) {\n                target = target.parentElement;\n            } else {\n                if (!this._targetBoundaryScrolled) {\n                    this.clearSelection();\n                }\n\n                return;\n            }\n\n        }\n\n        // Grab the current store first in case it gets set back\n        const {stored} = this._selection;\n        this._emitEvent('start', evt);\n\n        if (evt.shiftKey && range && this._latestElement) {\n            const reference = this._latestElement;\n\n            // Resolve the correct range\n            const [preceding, following] = reference.compareDocumentPosition(target) & 4 ?\n                [target, reference] : [reference, target];\n\n            const rangeItems = [...this._selectables.filter(el =>\n                (el.compareDocumentPosition(preceding) & 4) &&\n                (el.compareDocumentPosition(following) & 2)\n            ), preceding, following];\n\n            this.select(rangeItems);\n            this._latestElement = reference; // the latestElement is by default cleared in .select()\n        } else if (\n            stored.includes(target) && (\n                stored.length === 1 || evt.ctrlKey ||\n                stored.every(v => this._selection.stored.includes(v))\n            )\n        ) {\n            this.deselect(target);\n        } else {\n            this.select(target);\n            this._latestElement = target;\n        }\n    }\n\n    _delayedTapMove(evt: MouseEvent | TouchEvent): void {\n        const {container, document, behaviour: {startThreshold}} = this._options;\n        const {x1, y1} = this._areaLocation; // Coordinates of the first \"tap\"\n        const {x, y} = simplifyEvent(evt);\n\n        // Check the pixel threshold\n        if (\n\n            // Single number for both coordinates\n            (typeof startThreshold === 'number' && abs((x + y) - (x1 + y1)) >= startThreshold) ||\n\n            // Different x and y threshold\n            (typeof startThreshold === 'object' && abs(x - x1) >= (startThreshold as Coordinates).x || abs(y - y1) >= (startThreshold as Coordinates).y)\n        ) {\n            off(document, ['mousemove', 'touchmove'], this._delayedTapMove, {passive: false});\n\n            if (this._emitEvent('beforedrag', evt) === false) {\n                off(document, ['mouseup', 'touchcancel', 'touchend'], this._onTapStop);\n                return;\n            }\n\n            on(document, ['mousemove', 'touchmove'], this._onTapMove, {passive: false});\n\n            // Make area element visible\n            css(this._area, 'display', 'block');\n\n            // Append selection-area to the dom\n            selectAll(container, document)[0].appendChild(this._clippingElement);\n\n            this.resolveSelectables();\n\n            // An action is recognized as single-select until the user performed a multi-selection\n            this._singleClick = false;\n\n            // Just saving the boundaries of this container for later\n            this._targetRect = this._targetElement!.getBoundingClientRect();\n\n            // Find a container and check if it's scrollable\n            this._scrollAvailable =\n                this._targetElement!.scrollHeight !== this._targetElement!.clientHeight ||\n                this._targetElement!.scrollWidth !== this._targetElement!.clientWidth;\n\n            if (this._scrollAvailable) {\n\n                // Detect mouse scrolling\n                on(this._targetElement, 'wheel', this._manualScroll, {passive: false});\n\n                /**\n                 * The selection-area will also cover another element\n                 * out of the current scrollable parent. So find all elements\n                 * that are in the current scrollable element. Now these are\n                 * the only selectables instead of all.\n                 */\n                this._selectables = this._selectables.filter(s => this._targetElement!.contains(s));\n            }\n\n            // Re-setup selection area and fire event\n            this._setupSelectionArea();\n            this._emitEvent('start', evt);\n            this._onTapMove(evt);\n        }\n\n        this._handleMoveEvent(evt);\n    }\n\n    _setupSelectionArea(): void {\n        const {_clippingElement, _targetElement, _area} = this;\n        const tr = this._targetRect = _targetElement!.getBoundingClientRect();\n\n        if (this._scrollAvailable) {\n\n            /**\n             * To clip the area, the selection area has a parent\n             * which has exactly the same dimensions as the scrollable element.\n             * Now if the area exceeds these boundaries, it will be cropped.\n             */\n            css(_clippingElement, {\n                top: tr.top,\n                left: tr.left,\n                width: tr.width,\n                height: tr.height\n            });\n\n            /**\n             * The area element is relative to the clipping element,\n             * but when this is moved or transformed, we need to correct\n             * the positions via a negative margin.\n             */\n            css(_area, {\n                marginTop: -tr.top,\n                marginLeft: -tr.left\n            });\n        } else {\n\n            // \"Reset\" styles\n            css(_clippingElement, {\n                top: 0,\n                left: 0,\n                width: '100%',\n                height: '100%'\n            });\n\n            css(_area, {\n                marginTop: 0,\n                marginLeft: 0\n            });\n        }\n    }\n\n    _onTapMove(evt: MouseEvent | TouchEvent): void {\n        const {_scrollSpeed, _areaLocation, _options, _frame} = this;\n        const {speedDivider} = _options.behaviour.scrolling;\n        const _targetElement = this._targetElement as Element;\n\n        const {x, y} = simplifyEvent(evt);\n        _areaLocation.x2 = x;\n        _areaLocation.y2 = y;\n\n        if (this._scrollAvailable && !this._scrollingActive && (_scrollSpeed.y || _scrollSpeed.x)) {\n\n            // Continuous scrolling\n            this._scrollingActive = true;\n\n            const scroll = () => {\n                if (!_scrollSpeed.x && !_scrollSpeed.y) {\n                    this._scrollingActive = false;\n                    return;\n                }\n\n                // Reduce velocity, use ceil in both directions to scroll at least 1px per frame\n                const {scrollTop, scrollLeft} = _targetElement;\n\n                if (_scrollSpeed.y) {\n                    _targetElement.scrollTop += ceil(_scrollSpeed.y / speedDivider);\n                    _areaLocation.y1 -= _targetElement.scrollTop - scrollTop;\n                }\n\n                if (_scrollSpeed.x) {\n                    _targetElement.scrollLeft += ceil(_scrollSpeed.x / speedDivider);\n                    _areaLocation.x1 -= _targetElement.scrollLeft - scrollLeft;\n                }\n\n                /**\n                 * We changed the start coordinates -> redraw the selection-area\n                 * We changed the dimensions of the area element -> re-calc selected elements\n                 * The selected elements array has been changed -> fire event\n                 */\n                _frame.next(evt);\n\n                // Keep scrolling even if the user stops to move his pointer\n                requestAnimationFrame(scroll);\n            };\n\n            requestAnimationFrame(scroll);\n        } else {\n\n            /**\n             * Perform redrawing only if scrolling is not active.\n             * If scrolling is active, this area is getting re-dragged by the\n             * anonymize scroll function.\n             */\n            _frame.next(evt);\n        }\n\n        this._handleMoveEvent(evt);\n    }\n\n    _handleMoveEvent(evt: MouseEvent | TouchEvent) {\n        const {features} = this._options;\n\n        /**\n         * - Prevent auto-refresh for when pulling down on touch devices.\n         * - Prevent auto-scroll by the browser when on safari, and scrolling is handled by this library.\n         */\n        if ((features.touch && isTouchDevice()) || (this._scrollAvailable && isSafariBrowser())) {\n            evt.preventDefault(); // Prevent swipe-down refresh\n        }\n    }\n\n    _onScroll(): void {\n        const {_scrollDelta, _options: {document}} = this;\n        const {scrollTop, scrollLeft} = document.scrollingElement ?? document.body;\n\n        // Adjust area start location\n        this._areaLocation.x1 += _scrollDelta.x - scrollLeft;\n        this._areaLocation.y1 += _scrollDelta.y - scrollTop;\n        _scrollDelta.x = scrollLeft;\n        _scrollDelta.y = scrollTop;\n\n        // The area needs to be set back as the target-container has changed in its position\n        this._setupSelectionArea();\n        this._frame.next(null);\n    }\n\n    _onStartAreaScroll(): void {\n        this._targetBoundaryScrolled = true;\n        off(this._targetElement, 'scroll', this._onStartAreaScroll);\n    }\n\n    _manualScroll(evt: ScrollEvent): void {\n        const {manualSpeed} = this._options.behaviour.scrolling;\n\n        // Consistent scrolling speed on all browsers\n        const deltaY = evt.deltaY ? (evt.deltaY > 0 ? 1 : -1) : 0;\n        const deltaX = evt.deltaX ? (evt.deltaX > 0 ? 1 : -1) : 0;\n        this._scrollSpeed.y += deltaY * manualSpeed;\n        this._scrollSpeed.x += deltaX * manualSpeed;\n        this._onTapMove(evt);\n\n        // Prevent default scrolling behavior, e.g. page scrolling\n        evt.preventDefault();\n    }\n\n    _recalculateSelectionAreaRect(): void {\n        const {_scrollSpeed, _areaLocation, _targetElement, _options} = this;\n        const {scrollTop, scrollHeight, clientHeight, scrollLeft, scrollWidth, clientWidth} = _targetElement as Element;\n        const _targetRect = this._targetRect as DOMRect;\n\n        const {x1, y1} = _areaLocation;\n        let {x2, y2} = _areaLocation;\n\n        const {behaviour: {scrolling: {startScrollMargins}}} = _options;\n\n        if (x2 < _targetRect.left + startScrollMargins.x) {\n            _scrollSpeed.x = scrollLeft ? -abs(_targetRect.left - x2 + startScrollMargins.x) : 0;\n            x2 = x2 < _targetRect.left ? _targetRect.left : x2;\n        } else if (x2 > _targetRect.right - startScrollMargins.x) {\n            _scrollSpeed.x = scrollWidth - scrollLeft - clientWidth ? abs(_targetRect.left + _targetRect.width - x2 - startScrollMargins.x) : 0;\n            x2 = x2 > _targetRect.right ? _targetRect.right : x2;\n        } else {\n            _scrollSpeed.x = 0;\n        }\n\n        if (y2 < _targetRect.top + startScrollMargins.y) {\n            _scrollSpeed.y = scrollTop ? -abs(_targetRect.top - y2 + startScrollMargins.y) : 0;\n            y2 = y2 < _targetRect.top ? _targetRect.top : y2;\n        } else if (y2 > _targetRect.bottom - startScrollMargins.y) {\n            _scrollSpeed.y = scrollHeight - scrollTop - clientHeight ? abs(_targetRect.top + _targetRect.height - y2 - startScrollMargins.y) : 0;\n            y2 = y2 > _targetRect.bottom ? _targetRect.bottom : y2;\n        } else {\n            _scrollSpeed.y = 0;\n        }\n\n        const x3 = min(x1, x2);\n        const y3 = min(y1, y2);\n        const x4 = max(x1, x2);\n        const y4 = max(y1, y2);\n\n        this._areaRect = new DOMRect(x3, y3, x4 - x3, y4 - y3);\n    }\n\n    _redrawSelectionArea(): void {\n        const {x, y, width, height} = this._areaRect;\n        const {style} = this._area;\n\n        // Using transform will make the area's borders look blurry\n        style.left = `${x}px`;\n        style.top = `${y}px`;\n        style.width = `${width}px`;\n        style.height = `${height}px`;\n    }\n\n    _onTapStop(evt: MouseEvent | TouchEvent | null, silent: boolean): void {\n        const {document, features} = this._options;\n        const {_singleClick} = this;\n\n        // Remove event handlers\n        off(this._targetElement, 'scroll', this._onStartAreaScroll);\n        off(document, ['mousemove', 'touchmove'], this._delayedTapMove);\n        off(document, ['touchmove', 'mousemove'], this._onTapMove);\n        off(document, ['mouseup', 'touchcancel', 'touchend'], this._onTapStop);\n        off(document, 'scroll', this._onScroll);\n\n        // Keep selection until the next time\n        this._keepSelection();\n\n        if (evt && _singleClick && features.singleTap.allow) {\n            this._onSingleTap(evt);\n        } else if (!_singleClick && !silent) {\n            this._updateElementSelection();\n            this._emitEvent('stop', evt);\n        }\n\n        this._scrollSpeed.x = 0;\n        this._scrollSpeed.y = 0;\n\n        // Unbind mouse scrolling listener\n        off(this._targetElement, 'wheel', this._manualScroll, {passive: true});\n\n        // Remove selection-area from dom\n        this._clippingElement.remove();\n\n        // Cancel current frame\n        this._frame?.cancel();\n\n        // Hide selection area\n        css(this._area, 'display', 'none');\n    }\n\n    _updateElementSelection(): void {\n        const {_selectables, _options, _selection, _areaRect} = this;\n        const {stored, selected, touched} = _selection;\n        const {intersect, overlap} = _options.behaviour;\n\n        const invert = overlap === 'invert';\n        const newlyTouched: Element[] = [];\n        const added: Element[] = [];\n        const removed: Element[] = [];\n\n        // Find newly selected elements\n        for (let i = 0; i < _selectables.length; i++) {\n            const node = _selectables[i];\n\n            // Check if the area intersects an element\n            if (intersects(_areaRect, node.getBoundingClientRect(), intersect)) {\n\n                // Check if the element wasn't present in the last selection.\n                if (!selected.includes(node)) {\n\n                    // Check if the user wants to invert the selection for already selected elements\n                    if (invert && stored.includes(node)) {\n                        removed.push(node);\n                        continue;\n                    } else {\n                        added.push(node);\n                    }\n                } else if (stored.includes(node) && !touched.includes(node)) {\n                    touched.push(node);\n                }\n\n                newlyTouched.push(node);\n            }\n        }\n\n        // Re-select elements which were previously stored\n        if (invert) {\n            added.push(...stored.filter(v => !selected.includes(v)));\n        }\n\n        // Check which elements where removed since last selection\n        const keep = overlap === 'keep';\n        for (let i = 0; i < selected.length; i++) {\n            const node = selected[i];\n\n            if (!newlyTouched.includes(node) && !(\n\n                // Check if the user wants to keep previously selected elements, e.g.,\n                // not make them part of the current selection as soon as they're touched.\n                keep && stored.includes(node)\n            )) {\n                removed.push(node);\n            }\n        }\n\n        _selection.selected = newlyTouched;\n        _selection.changed = {added, removed};\n\n        // Prevent range selection when selection an area.\n        this._latestElement = undefined;\n    }\n\n    _emitEvent(name: keyof SelectionEvents, evt: MouseEvent | TouchEvent | null): unknown {\n        return this.emit(name, {\n            event: evt,\n            store: this._selection,\n            selection: this\n        });\n    }\n\n    _keepSelection(): void {\n        const {_options, _selection} = this;\n        const {selected, changed, touched, stored} = _selection;\n        const addedElements = selected.filter(el => !stored.includes(el));\n\n        switch (_options.behaviour.overlap) {\n            case 'drop': {\n                _selection.stored = [\n                    ...addedElements,\n                    ...stored.filter(el => !touched.includes(el))  // Elements not touched\n                ];\n                break;\n            }\n            case 'invert': {\n                _selection.stored = [\n                    ...addedElements,\n                    ...stored.filter(el => !changed.removed.includes(el))  // Elements not removed from selection\n                ];\n                break;\n            }\n            case 'keep': {\n                _selection.stored = [\n                    ...stored,\n                    ...selected.filter(el => !stored.includes(el)) // Newly added\n                ];\n                break;\n            }\n        }\n    }\n\n    /**\n     * Manually triggers the start of a selection\n     * @param evt A MouseEvent / TouchEvent-like object\n     * @param silent If beforestart should be fired,\n     */\n    trigger(evt: MouseEvent | TouchEvent, silent = true): void {\n        this._onTapStart(evt, silent);\n    }\n\n    /**\n     * Can be used if during a selection elements have been added.\n     * Will update everything that can be selected.\n     */\n    resolveSelectables(): void {\n        this._selectables = selectAll(this._options.selectables, this._options.document);\n    }\n\n    /**\n     * Same as deselecting, but for all elements currently selected.\n     * @param includeStored If the store should also get cleared\n     * @param quiet If move / stop events should be fired\n     */\n    clearSelection(includeStored = true, quiet = false): void {\n        const {selected, stored, changed} = this._selection;\n\n        changed.added = [];\n        changed.removed.push(\n            ...selected,\n            ...(includeStored ? stored : [])\n        );\n\n        // Fire event\n        if (!quiet) {\n            this._emitEvent('move', null);\n            this._emitEvent('stop', null);\n        }\n\n        // Reset state\n        this._selection = makeSelectionStore(includeStored ? [] : stored);\n    }\n\n    /**\n     * @returns {Array} Selected elements\n     */\n    getSelection(): Element[] {\n        return this._selection.stored;\n    }\n\n    /**\n     * @returns {HTMLElement} The selection area element\n     */\n    getSelectionArea(): HTMLElement {\n        return this._area;\n    }\n\n    /**\n     * Cancel the current selection process, pass true to fire a stop event after cancel.\n     */\n    cancel(keepEvent = false): void {\n        this._onTapStop(null, !keepEvent);\n    }\n\n    /**\n     * Unbinds all events and removes the area-element.\n     */\n    destroy(): void {\n        this.cancel();\n        this.disable();\n        this._clippingElement.remove();\n        super.unbindAllListeners();\n    }\n\n    /* eslint-disable no-invalid-this */\n    disable = this._toggleStartEvents.bind(this, false);\n    enable = this._toggleStartEvents;\n\n    /**\n     * Adds elements to the selection\n     * @param query - CSS Query, can be an array of queries\n     * @param quiet - If this should not trigger the move event\n     */\n    select(query: SelectAllSelectors, quiet = false): Element[] {\n        const {changed, selected, stored} = this._selection;\n        const elements = selectAll(query, this._options.document).filter(el =>\n            !selected.includes(el) &&\n            !stored.includes(el)\n        );\n\n        // Update element lists\n        stored.push(...elements);\n        selected.push(...elements);\n        changed.added.push(...elements);\n        changed.removed = [];\n\n        // We don't know which element was \"selected\" first, so clear it\n        this._latestElement = undefined;\n\n        // Fire event\n        if (!quiet) {\n            this._emitEvent('move', null);\n            this._emitEvent('stop', null);\n        }\n\n        return elements;\n    }\n\n    /**\n     * Removes a particular element from the selection.\n     * @param query - CSS Query, can be an array of queries\n     * @param quiet - If this should not trigger the move event\n     */\n    deselect(query: SelectAllSelectors, quiet = false) {\n        const {selected, stored, changed} = this._selection;\n\n        const elements = selectAll(query, this._options.document).filter(el =>\n            selected.includes(el) ||\n            stored.includes(el)\n        );\n\n        if (!elements.length) {\n            return;\n        }\n\n        this._selection.stored = stored.filter(el => !elements.includes(el));\n        this._selection.selected = selected.filter(el => !elements.includes(el));\n        this._selection.changed.added = [];\n        this._selection.changed.removed.push(\n            ...elements.filter(el => !changed.removed.includes(el))\n        );\n\n        // We don't know which element was \"selected\" first, so clear it\n        this._latestElement = undefined;\n\n        // Fire event\n        if (!quiet) {\n            this._emitEvent('move', null);\n            this._emitEvent('stop', null);\n        }\n    }\n}\n"],"names":["EventTarget","__publicField","event","cb","set","_a","data","ok","unitify","val","unit","css","style","attr","key","value","eventListener","method","items","events","fn","options","el","ev","on","off","simplifyEvent","evt","clientX","clientY","target","intersects","a","b","mode","bxc","byc","selectAll","selector","doc","list","nodes","i","l","item","isTouchDevice","isSafariBrowser","frames","previousArgs","frameId","lock","args","shouldTrigger","triggers","trigger","reqButtonIsPressed","allReqModifiersArePressed","modifier","abs","max","min","ceil","makeSelectionStore","stored","SelectionArea","opt","_b","_d","_c","_e","document","selectionAreaClass","selectionContainerClass","activate","features","silent","x","y","startAreas","boundaries","behaviour","targetBoundingClientRect","resolvedStartAreas","resolvedBoundaries","evtPath","targetStartArea","scrollElement","intersect","range","e","v","right","left","top","bottom","reference","preceding","following","rangeItems","container","startThreshold","x1","y1","s","_clippingElement","_targetElement","_area","tr","_scrollSpeed","_areaLocation","_options","_frame","speedDivider","scroll","scrollTop","scrollLeft","_scrollDelta","manualSpeed","deltaY","deltaX","scrollHeight","clientHeight","scrollWidth","clientWidth","_targetRect","x2","y2","startScrollMargins","x3","y3","x4","y4","width","height","_singleClick","_selectables","_selection","_areaRect","selected","touched","overlap","invert","newlyTouched","added","removed","node","keep","name","changed","addedElements","includeStored","quiet","keepEvent","query","elements"],"mappings":"kYAKO,MAAMA,CAAqC,CAA3C,cACcC,EAAA,sBAAiB,KA6B3BA,EAAA,UAAK,KAAK,kBACVA,EAAA,WAAM,KAAK,qBACXA,EAAA,YAAO,KAAK,eA7BZ,iBAAyCC,EAAUC,EAAqB,CAC3E,MAAMC,EAAM,KAAK,WAAW,IAAIF,CAAK,OAAS,IACzC,YAAA,WAAW,IAAIA,EAAOE,CAAG,EAC9BA,EAAI,IAAID,CAAiB,EAClB,IACX,CAEO,oBAA4CD,EAAUC,EAAqB,OAC9E,OAAAE,EAAA,KAAK,WAAW,IAAIH,CAAK,IAAzB,MAAAG,EAA4B,OAAOF,GAC5B,IACX,CAEO,cAAsCD,KAAaI,EAAsC,CAC5F,IAAIC,EAAK,GACT,UAAWJ,KAAO,KAAK,WAAW,IAAID,CAAK,GAAK,GAC5CK,EAAMJ,EAAG,GAAGG,CAAI,IAAM,IAAUC,EAG7B,OAAAA,CACX,CAEO,oBAA2B,CAC9B,KAAK,WAAW,OACpB,CAOJ,CCtCA,MAAMC,EAAU,CAACC,EAAsBC,EAAO,OACnC,OAAOD,GAAQ,SAAWA,EAAMC,EAAOD,EAY3C,SAASE,EACZ,CAAC,MAAAC,GACDC,EACAJ,EACI,CACA,GAAA,OAAOI,GAAS,SAEhB,SAAW,CAACC,EAAKC,CAAK,IAAK,OAAO,QAAQF,CAAI,EAC1CE,IAAU,SAAcH,EAAME,CAAU,EAAIN,EAAQO,CAAK,QAGtDN,IAAQ,SACTG,EAAAC,CAAW,EAAIL,EAAQC,CAAG,EAExC,CCdA,MAAMO,EAAiBC,GAAmB,CACtCC,EACAC,EACAC,EAAiBC,EAAU,KACR,CAGfH,aAAiB,gBAAkBA,aAAiB,SAC5CA,EAAA,MAAM,KAAKA,CAAK,EAChB,MAAM,QAAQA,CAAK,IAC3BA,EAAQ,CAACA,CAAK,GAGb,MAAM,QAAQC,CAAM,IACrBA,EAAS,CAACA,CAAM,GAGpB,UAAWG,KAAMJ,EACb,GAAII,EACA,UAAWC,KAAMJ,EACVG,EAAAL,CAAM,EAAEM,EAAIH,EAAqB,CAAC,QAAS,GAAO,GAAGC,CAAA,CAAQ,EAK5E,MAAO,CAACH,EAAOC,EAAQC,EAAIC,CAAO,CACtC,EAUaG,EAAKR,EAAc,kBAAkB,EAUrCS,EAAMT,EAAc,qBAAqB,EAMzCU,EAAiBC,GAIzB,OACK,KAAA,CAAC,QAAAC,EAAS,QAAAC,EAAS,OAAAC,CAAA,IAAUzB,EAAAsB,EAAI,UAAJ,YAAAtB,EAAc,KAAMsB,EACvD,MAAO,CAAC,EAAGC,EAAS,EAAGC,EAAS,OAAAC,CAAM,CAC1C,EC/DO,SAASC,EAAWC,EAAYC,EAAYC,EAAqB,QAAkB,CACtF,OAAQA,EAAM,CACV,IAAK,SAAU,CACX,MAAMC,EAAMF,EAAE,KAAOA,EAAE,MAAQ,EACzBG,EAAMH,EAAE,IAAMA,EAAE,OAAS,EAExB,OAAAE,GAAOH,EAAE,MACZG,GAAOH,EAAE,OACTI,GAAOJ,EAAE,KACTI,GAAOJ,EAAE,MACjB,CACA,IAAK,QACD,OAAOC,EAAE,MAAQD,EAAE,MACfC,EAAE,KAAOD,EAAE,KACXC,EAAE,OAASD,EAAE,OACbC,EAAE,QAAUD,EAAE,OAEtB,IAAK,QACD,OAAOA,EAAE,OAASC,EAAE,MAChBD,EAAE,MAAQC,EAAE,OACZD,EAAE,QAAUC,EAAE,KACdD,EAAE,KAAOC,EAAE,MAEvB,CACJ,CCzBgB,SAAAI,EAAUC,EAA8BC,EAAgB,SAAqB,CACnF,MAAAC,EAAQ,MAAM,QAAQF,CAAQ,EAAiBA,EAAb,CAACA,CAAQ,EACjD,IAAIG,EAAmB,CAAA,EAEvB,QAASC,EAAI,EAAGC,EAAIH,EAAK,OAAQE,EAAIC,EAAGD,IAAK,CACnC,MAAAE,EAAOJ,EAAKE,CAAC,EAEf,OAAOE,GAAS,SAKRH,EAAAA,EAAM,OAAO,MAAM,KAAKF,EAAI,iBAAiBK,CAAI,CAAC,CAAC,EACpDA,aAAgB,SACvBH,EAAM,KAAKG,CAAI,CAEvB,CAEO,OAAAH,CACX,CCzBO,MAAMI,EAAgB,IAAe,WAAW,kCAAkC,EAAE,QAG9EC,EAAkB,IAAe,WAAY,OCI7CC,EAAiC3B,GAAqB,CAC3D,IAAA4B,EACAC,EAAU,GACVC,EAAO,GAEJ,MAAA,CACH,QAAQC,EAA2B,CAChBH,EAAAG,EAEVD,IACMA,EAAA,GACPD,EAAU,sBAAsB,IAAM,CAClC7B,EAAG,GAAG4B,CAAY,EACXE,EAAA,EAAA,CACV,EAET,EACA,QAAS,CACL,qBAAqBD,CAAO,EACrBC,EAAA,EACX,CAAA,CAER,ECrBgB,SAAAE,EAAclD,EAAmBmD,EAA8B,CAC3E,UAAWC,KAAWD,EAAU,CAExB,GAAA,OAAOC,GAAY,SACnB,OAAOpD,EAAM,SAAWoD,EAIxB,GAAA,OAAOA,GAAY,SAAU,CACvB,MAAAC,EAAqBD,EAAQ,SAAWpD,EAAM,OAE9CsD,EAA4BF,EAAQ,UAAU,MAAOG,GAAa,CACpE,OAAQA,EAAU,CACd,IAAK,MACD,OAAOvD,EAAM,OACjB,IAAK,OACM,OAAAA,EAAM,SAAWA,EAAM,QAClC,IAAK,QACD,OAAOA,EAAM,QACrB,CAAA,CACH,EAED,OAAOqD,GAAsBC,CACjC,CACJ,CAGO,MAAA,EACX,CC7BA,KAAM,CAAC,IAAAE,EAAK,IAAAC,EAAK,IAAAC,EAAK,KAAAC,GAAQ,KAExBC,EAAqB,CAACC,EAAoB,MAAwB,CACpE,OAAAA,EACA,SAAU,CAAC,EACX,QAAS,CAAC,EACV,QAAS,CAAC,MAAO,GAAI,QAAS,CAAA,CAAE,CACpC,GAEA,MAAqBC,UAAsBhE,CAA6B,CAmCpE,YAAYiE,EAA8B,eAChC,QAhCOhE,EAAA,iBAGTA,EAAA,kBAA6B6D,EAAmB,GAGvC7D,EAAA,cACAA,EAAA,yBAGTA,EAAA,uBACAA,EAAA,wBACAA,EAAA,+BAA0B,IAC1BA,EAAA,oBACAA,EAAA,oBAA0B,CAAA,GAC1BA,EAAA,uBAGAA,EAAA,qBAA8B,CAAC,GAAI,EAAG,GAAI,EAAG,GAAI,EAAG,GAAI,IACxDA,EAAA,iBAAY,IAAI,SAGhBA,EAAA,oBAAe,IACfA,EAAA,eAGAA,EAAA,wBAAmB,IACnBA,EAAA,wBAAmB,IACnBA,EAAA,oBAA4B,CAAC,EAAG,EAAG,EAAG,CAAC,GACvCA,EAAA,oBAA4B,CAAC,EAAG,EAAG,EAAG,CAAC,GA6rB/CA,EAAA,eAAU,KAAK,mBAAmB,KAAK,KAAM,EAAK,GAClDA,EAAA,cAAS,KAAK,oBAzrBV,KAAK,SAAW,CACZ,mBAAoB,iBACpB,wBAAyB,OACzB,YAAa,CAAC,EACd,SAAU,OAAO,SACjB,WAAY,CAAC,MAAM,EACnB,WAAY,CAAC,MAAM,EACnB,UAAW,OACX,GAAGgE,EAEH,UAAW,CACP,QAAS,SACT,UAAW,QACX,SAAU,CAAC,CAAC,EACZ,GAAGA,EAAI,UACP,gBAAgB5D,EAAA4D,EAAI,YAAJ,MAAA5D,EAAe,eAC3B,OAAO4D,EAAI,UAAU,gBAAmB,SACpCA,EAAI,UAAU,eACd,CAAC,EAAG,GAAI,EAAG,GAAI,GAAGA,EAAI,UAAU,cAAc,EAAI,CAAC,EAAG,GAAI,EAAG,EAAE,EACvE,UAAW,CACP,aAAc,GACd,YAAa,IACb,IAAGC,EAAAD,EAAI,YAAJ,YAAAC,EAAe,UAClB,mBAAoB,CAChB,EAAG,EACH,EAAG,EACH,IAAGC,GAAAC,EAAAH,EAAI,YAAJ,YAAAG,EAAe,YAAf,YAAAD,EAA0B,kBACjC,CACJ,CACJ,EAEA,SAAU,CACN,MAAO,GACP,MAAO,GACP,eAAgB,GAChB,GAAGF,EAAI,SACP,UAAW,CACP,MAAO,GACP,UAAW,SACX,IAAGI,EAAAJ,EAAI,WAAJ,YAAAI,EAAc,SACrB,CACJ,CAAA,EAKJ,UAAWvD,KAAO,OAAO,oBAAoB,OAAO,eAAe,IAAI,CAAC,EAChE,OAAQ,KAAaA,CAAG,GAAM,aAC7B,KAAaA,CAAG,EAAK,KAAaA,CAAG,EAAE,KAAK,IAAI,GAIzD,KAAM,CAAC,SAAAwD,EAAU,mBAAAC,EAAoB,wBAAAC,CAAA,EAA2B,KAAK,SAChE,KAAA,MAAQF,EAAS,cAAc,KAAK,EACpC,KAAA,iBAAmBA,EAAS,cAAc,KAAK,EAC/C,KAAA,iBAAiB,YAAY,KAAK,KAAK,EAEvC,KAAA,MAAM,UAAU,IAAIC,CAAkB,EAEvCC,GACK,KAAA,iBAAiB,UAAU,IAAIA,CAAuB,EAG/D7D,EAAI,KAAK,MAAO,CACZ,WAAY,0CACZ,IAAK,EACL,KAAM,EACN,SAAU,OAAA,CACb,EAEDA,EAAI,KAAK,iBAAkB,CACvB,SAAU,SACV,SAAU,QACV,UAAW,uBACX,cAAe,OACf,OAAQ,GAAA,CACX,EAEI,KAAA,OAASoC,EAAQpB,GAAiC,CACnD,KAAK,8BAA8B,EACnC,KAAK,wBAAwB,EACxB,KAAA,WAAW,OAAQA,CAAG,EAC3B,KAAK,qBAAqB,CAAA,CAC7B,EAED,KAAK,OAAO,CAChB,CAEA,mBAAmB8C,EAAW,GAAY,CACtC,KAAM,CAAC,SAAAH,EAAU,SAAAI,GAAY,KAAK,SAC5BtD,EAAKqD,EAAWjD,EAAKC,EAExBL,EAAAkD,EAAU,YAAa,KAAK,WAAW,EAEtCI,EAAS,OACTtD,EAAGkD,EAAU,aAAc,KAAK,YAAa,CAAC,QAAS,GAAM,CAErE,CAEA,YAAY3C,EAA8BgD,EAAS,GAAa,CAC5D,KAAM,CAAC,EAAAC,EAAG,EAAAC,EAAG,OAAA/C,CAAM,EAAIJ,EAAcC,CAAG,EAClC,CAAC,SAAA2C,EAAU,WAAAQ,EAAY,WAAAC,EAAY,SAAAL,EAAU,UAAAM,GAAa,KAAK,SAC/DC,EAA2BnD,EAAO,wBAExC,GAAIH,aAAe,YAAc,CAACyB,EAAczB,EAAKqD,EAAU,QAAQ,EACnE,OAIE,MAAAE,EAAqB7C,EAAUyC,EAAYR,CAAQ,EACnDa,EAAqB9C,EAAU0C,EAAYT,CAAQ,EAGzD,KAAK,eAAiBa,EAAmB,KACrC7D,GAAAS,EAAWT,EAAG,sBAAA,EAAyB2D,CAAwB,CAAA,EAI7D,MAAAG,EAAUzD,EAAI,eACd0D,EAAkBH,EAAmB,QAAWE,EAAQ,SAAS9D,CAAE,CAAC,EAO1E,GANK,KAAA,gBAAkB6D,EAAmB,QAAWC,EAAQ,SAAS9D,CAAE,CAAC,EAErE,CAAC,KAAK,gBAAkB,CAAC+D,GAAmB,CAAC,KAAK,iBAIlD,CAACV,GAAU,KAAK,WAAW,cAAehD,CAAG,IAAM,GACnD,OAGC,KAAA,cAAgB,CAAC,GAAIiD,EAAG,GAAIC,EAAG,GAAI,EAAG,GAAI,CAAC,EAG1C,MAAAS,EAAgBhB,EAAS,kBAAoBA,EAAS,KAC5D,KAAK,aAAe,CAAC,EAAGgB,EAAc,WAAY,EAAGA,EAAc,WAGnE,KAAK,aAAe,GACf,KAAA,eAAe,GAAO,EAAI,EAE5B9D,EAAA8C,EAAU,CAAC,YAAa,WAAW,EAAG,KAAK,gBAAiB,CAAC,QAAS,EAAA,CAAM,EAC/E9C,EAAG8C,EAAU,CAAC,UAAW,cAAe,UAAU,EAAG,KAAK,UAAU,EACjE9C,EAAA8C,EAAU,SAAU,KAAK,SAAS,EAEjCI,EAAS,iBACT,KAAK,wBAA0B,GAC/BlD,EAAG,KAAK,gBAAiB,SAAU,KAAK,kBAAkB,EAElE,CAEA,aAAaG,EAAoC,CACvC,KAAA,CAAC,UAAW,CAAC,UAAA4D,GAAY,MAAAC,CAAK,EAAI,KAAK,SAAS,SAChDC,EAAI/D,EAAcC,CAAG,EACvB,IAAAG,EAEJ,GAAIyD,IAAc,SACdzD,EAAS2D,EAAE,eACJF,IAAc,QAAS,CAC9B,KAAK,mBAAmB,EAElB,KAAA,CAAC,EAAAX,EAAG,EAAAC,CAAK,EAAAY,EACN3D,EAAA,KAAK,aAAa,KAAU4D,GAAA,CACjC,KAAM,CAAC,MAAAC,EAAO,KAAAC,EAAM,IAAAC,EAAK,OAAAC,GAAUJ,EAAE,wBACrC,OAAOd,EAAIe,GAASf,EAAIgB,GAAQf,EAAIiB,GAAUjB,EAAIgB,CAAA,CACrD,CACL,CAEA,GAAI,CAAC/D,EACD,OAYJ,IAHA,KAAK,mBAAmB,EAGjB,CAAC,KAAK,aAAa,SAASA,CAAM,GACrC,GAAIA,EAAO,cACPA,EAASA,EAAO,kBACb,CACE,KAAK,yBACN,KAAK,eAAe,EAGxB,MACJ,CAKE,KAAA,CAAC,OAAAiC,CAAM,EAAI,KAAK,WAGtB,GAFK,KAAA,WAAW,QAASpC,CAAG,EAExBA,EAAI,UAAY6D,GAAS,KAAK,eAAgB,CAC9C,MAAMO,EAAY,KAAK,eAGjB,CAACC,EAAWC,CAAS,EAAIF,EAAU,wBAAwBjE,CAAM,EAAI,EACvE,CAACA,EAAQiE,CAAS,EAAI,CAACA,EAAWjE,CAAM,EAEtCoE,EAAa,CAAC,GAAG,KAAK,aAAa,OAAO5E,GAC3CA,EAAG,wBAAwB0E,CAAS,EAAI,GACxC1E,EAAG,wBAAwB2E,CAAS,EAAI,CAAA,EAC1CD,EAAWC,CAAS,EAEvB,KAAK,OAAOC,CAAU,EACtB,KAAK,eAAiBH,CAAA,MAEtBhC,EAAO,SAASjC,CAAM,IAClBiC,EAAO,SAAW,GAAKpC,EAAI,SAC3BoC,EAAO,SAAW,KAAK,WAAW,OAAO,SAAS2B,CAAC,CAAC,GAGxD,KAAK,SAAS5D,CAAM,GAEpB,KAAK,OAAOA,CAAM,EAClB,KAAK,eAAiBA,EAE9B,CAEA,gBAAgBH,EAAoC,CAC1C,KAAA,CAAC,UAAAwE,EAAW,SAAA7B,EAAU,UAAW,CAAC,eAAA8B,IAAmB,KAAK,SAC1D,CAAC,GAAAC,EAAI,GAAAC,GAAM,KAAK,cAChB,CAAC,EAAA1B,EAAG,EAAAC,CAAC,EAAInD,EAAcC,CAAG,EAGhC,GAGK,OAAOyE,GAAmB,UAAY1C,EAAKkB,EAAIC,GAAMwB,EAAKC,EAAG,GAAKF,GAGlE,OAAOA,GAAmB,UAAY1C,EAAIkB,EAAIyB,CAAE,GAAMD,EAA+B,GAAK1C,EAAImB,EAAIyB,CAAE,GAAMF,EAA+B,EAC5I,CAGE,GAFI3E,EAAA6C,EAAU,CAAC,YAAa,WAAW,EAAG,KAAK,gBAAiB,CAAC,QAAS,EAAA,CAAM,EAE5E,KAAK,WAAW,aAAc3C,CAAG,IAAM,GAAO,CAC9CF,EAAI6C,EAAU,CAAC,UAAW,cAAe,UAAU,EAAG,KAAK,UAAU,EACrE,MACJ,CAEG9C,EAAA8C,EAAU,CAAC,YAAa,WAAW,EAAG,KAAK,WAAY,CAAC,QAAS,EAAA,CAAM,EAGtE3D,EAAA,KAAK,MAAO,UAAW,OAAO,EAGlC0B,EAAU8D,EAAW7B,CAAQ,EAAE,CAAC,EAAE,YAAY,KAAK,gBAAgB,EAEnE,KAAK,mBAAmB,EAGxB,KAAK,aAAe,GAGf,KAAA,YAAc,KAAK,eAAgB,sBAAsB,EAGzD,KAAA,iBACD,KAAK,eAAgB,eAAiB,KAAK,eAAgB,cAC3D,KAAK,eAAgB,cAAgB,KAAK,eAAgB,YAE1D,KAAK,mBAGF9C,EAAA,KAAK,eAAgB,QAAS,KAAK,cAAe,CAAC,QAAS,GAAM,EAQhE,KAAA,aAAe,KAAK,aAAa,UAAY,KAAK,eAAgB,SAAS+E,CAAC,CAAC,GAItF,KAAK,oBAAoB,EACpB,KAAA,WAAW,QAAS5E,CAAG,EAC5B,KAAK,WAAWA,CAAG,CACvB,CAEA,KAAK,iBAAiBA,CAAG,CAC7B,CAEA,qBAA4B,CACxB,KAAM,CAAC,iBAAA6E,EAAkB,eAAAC,EAAgB,MAAAC,CAAA,EAAS,KAC5CC,EAAK,KAAK,YAAcF,EAAgB,sBAAsB,EAEhE,KAAK,kBAOL9F,EAAI6F,EAAkB,CAClB,IAAKG,EAAG,IACR,KAAMA,EAAG,KACT,MAAOA,EAAG,MACV,OAAQA,EAAG,MAAA,CACd,EAODhG,EAAI+F,EAAO,CACP,UAAW,CAACC,EAAG,IACf,WAAY,CAACA,EAAG,IAAA,CACnB,IAIDhG,EAAI6F,EAAkB,CAClB,IAAK,EACL,KAAM,EACN,MAAO,OACP,OAAQ,MAAA,CACX,EAED7F,EAAI+F,EAAO,CACP,UAAW,EACX,WAAY,CAAA,CACf,EAET,CAEA,WAAW/E,EAAoC,CAC3C,KAAM,CAAC,aAAAiF,EAAc,cAAAC,EAAe,SAAAC,EAAU,OAAAC,GAAU,KAClD,CAAC,aAAAC,CAAgB,EAAAF,EAAS,UAAU,UACpCL,EAAiB,KAAK,eAEtB,CAAC,EAAA7B,EAAG,EAAAC,CAAC,EAAInD,EAAcC,CAAG,EAI5B,GAHJkF,EAAc,GAAKjC,EACnBiC,EAAc,GAAKhC,EAEf,KAAK,kBAAoB,CAAC,KAAK,mBAAqB+B,EAAa,GAAKA,EAAa,GAAI,CAGvF,KAAK,iBAAmB,GAExB,MAAMK,EAAS,IAAM,CACjB,GAAI,CAACL,EAAa,GAAK,CAACA,EAAa,EAAG,CACpC,KAAK,iBAAmB,GACxB,MACJ,CAGM,KAAA,CAAC,UAAAM,EAAW,WAAAC,CAAc,EAAAV,EAE5BG,EAAa,IACbH,EAAe,WAAa5C,EAAK+C,EAAa,EAAII,CAAY,EAChDH,EAAA,IAAMJ,EAAe,UAAYS,GAG/CN,EAAa,IACbH,EAAe,YAAc5C,EAAK+C,EAAa,EAAII,CAAY,EACjDH,EAAA,IAAMJ,EAAe,WAAaU,GAQpDJ,EAAO,KAAKpF,CAAG,EAGf,sBAAsBsF,CAAM,CAAA,EAGhC,sBAAsBA,CAAM,CAAA,MAQ5BF,EAAO,KAAKpF,CAAG,EAGnB,KAAK,iBAAiBA,CAAG,CAC7B,CAEA,iBAAiBA,EAA8B,CACrC,KAAA,CAAC,SAAA+C,CAAQ,EAAI,KAAK,UAMnBA,EAAS,OAAS7B,EAAA,GAAqB,KAAK,kBAAoBC,MACjEnB,EAAI,eAAe,CAE3B,CAEA,WAAkB,CACd,KAAM,CAAC,aAAAyF,EAAc,SAAU,CAAC,SAAA9C,IAAa,KACvC,CAAC,UAAA4C,EAAW,WAAAC,CAAc,EAAA7C,EAAS,kBAAoBA,EAAS,KAGjE,KAAA,cAAc,IAAM8C,EAAa,EAAID,EACrC,KAAA,cAAc,IAAMC,EAAa,EAAIF,EAC1CE,EAAa,EAAID,EACjBC,EAAa,EAAIF,EAGjB,KAAK,oBAAoB,EACpB,KAAA,OAAO,KAAK,IAAI,CACzB,CAEA,oBAA2B,CACvB,KAAK,wBAA0B,GAC/BzF,EAAI,KAAK,eAAgB,SAAU,KAAK,kBAAkB,CAC9D,CAEA,cAAcE,EAAwB,CAClC,KAAM,CAAC,YAAA0F,CAAA,EAAe,KAAK,SAAS,UAAU,UAGxCC,EAAS3F,EAAI,OAAUA,EAAI,OAAS,EAAI,EAAI,GAAM,EAClD4F,EAAS5F,EAAI,OAAUA,EAAI,OAAS,EAAI,EAAI,GAAM,EACnD,KAAA,aAAa,GAAK2F,EAASD,EAC3B,KAAA,aAAa,GAAKE,EAASF,EAChC,KAAK,WAAW1F,CAAG,EAGnBA,EAAI,eAAe,CACvB,CAEA,+BAAsC,CAClC,KAAM,CAAC,aAAAiF,EAAc,cAAAC,EAAe,eAAAJ,EAAgB,SAAAK,GAAY,KAC1D,CAAC,UAAAI,EAAW,aAAAM,EAAc,aAAAC,EAAc,WAAAN,EAAY,YAAAO,EAAa,YAAAC,CAAe,EAAAlB,EAChFmB,EAAc,KAAK,YAEnB,CAAC,GAAAvB,EAAI,GAAAC,CAAM,EAAAO,EACb,GAAA,CAAC,GAAAgB,EAAI,GAAAC,CAAM,EAAAjB,EAET,KAAA,CAAC,UAAW,CAAC,UAAW,CAAC,mBAAAkB,CAAkB,CAAA,CAAM,EAAAjB,EAEnDe,EAAKD,EAAY,KAAOG,EAAmB,GAC9BnB,EAAA,EAAIO,EAAa,CAACzD,EAAIkE,EAAY,KAAOC,EAAKE,EAAmB,CAAC,EAAI,EACnFF,EAAKA,EAAKD,EAAY,KAAOA,EAAY,KAAOC,GACzCA,EAAKD,EAAY,MAAQG,EAAmB,GACnDnB,EAAa,EAAIc,EAAcP,EAAaQ,EAAcjE,EAAIkE,EAAY,KAAOA,EAAY,MAAQC,EAAKE,EAAmB,CAAC,EAAI,EAClIF,EAAKA,EAAKD,EAAY,MAAQA,EAAY,MAAQC,GAElDjB,EAAa,EAAI,EAGjBkB,EAAKF,EAAY,IAAMG,EAAmB,GAC7BnB,EAAA,EAAIM,EAAY,CAACxD,EAAIkE,EAAY,IAAME,EAAKC,EAAmB,CAAC,EAAI,EACjFD,EAAKA,EAAKF,EAAY,IAAMA,EAAY,IAAME,GACvCA,EAAKF,EAAY,OAASG,EAAmB,GACpDnB,EAAa,EAAIY,EAAeN,EAAYO,EAAe/D,EAAIkE,EAAY,IAAMA,EAAY,OAASE,EAAKC,EAAmB,CAAC,EAAI,EACnID,EAAKA,EAAKF,EAAY,OAASA,EAAY,OAASE,GAEpDlB,EAAa,EAAI,EAGf,MAAAoB,EAAKpE,EAAIyC,EAAIwB,CAAE,EACfI,EAAKrE,EAAI0C,EAAIwB,CAAE,EACfI,EAAKvE,EAAI0C,EAAIwB,CAAE,EACfM,EAAKxE,EAAI2C,EAAIwB,CAAE,EAEhB,KAAA,UAAY,IAAI,QAAQE,EAAIC,EAAIC,EAAKF,EAAIG,EAAKF,CAAE,CACzD,CAEA,sBAA6B,CACzB,KAAM,CAAC,EAAArD,EAAG,EAAAC,EAAG,MAAAuD,EAAO,OAAAC,GAAU,KAAK,UAC7B,CAAC,MAAAzH,CAAK,EAAI,KAAK,MAGfA,EAAA,KAAO,GAAGgE,CAAC,KACXhE,EAAA,IAAM,GAAGiE,CAAC,KACVjE,EAAA,MAAQ,GAAGwH,CAAK,KAChBxH,EAAA,OAAS,GAAGyH,CAAM,IAC5B,CAEA,WAAW1G,EAAqCgD,EAAuB,OACnE,KAAM,CAAC,SAAAL,EAAU,SAAAI,GAAY,KAAK,SAC5B,CAAC,aAAA4D,CAAgB,EAAA,KAGvB7G,EAAI,KAAK,eAAgB,SAAU,KAAK,kBAAkB,EAC1DA,EAAI6C,EAAU,CAAC,YAAa,WAAW,EAAG,KAAK,eAAe,EAC9D7C,EAAI6C,EAAU,CAAC,YAAa,WAAW,EAAG,KAAK,UAAU,EACzD7C,EAAI6C,EAAU,CAAC,UAAW,cAAe,UAAU,EAAG,KAAK,UAAU,EACjE7C,EAAA6C,EAAU,SAAU,KAAK,SAAS,EAGtC,KAAK,eAAe,EAEhB3C,GAAO2G,GAAgB5D,EAAS,UAAU,MAC1C,KAAK,aAAa/C,CAAG,EACd,CAAC2G,GAAgB,CAAC3D,IACzB,KAAK,wBAAwB,EACxB,KAAA,WAAW,OAAQhD,CAAG,GAG/B,KAAK,aAAa,EAAI,EACtB,KAAK,aAAa,EAAI,EAGlBF,EAAA,KAAK,eAAgB,QAAS,KAAK,cAAe,CAAC,QAAS,GAAK,EAGrE,KAAK,iBAAiB,UAGtBpB,EAAA,KAAK,SAAL,MAAAA,EAAa,SAGTM,EAAA,KAAK,MAAO,UAAW,MAAM,CACrC,CAEA,yBAAgC,CAC5B,KAAM,CAAC,aAAA4H,EAAc,SAAAzB,EAAU,WAAA0B,EAAY,UAAAC,GAAa,KAClD,CAAC,OAAA1E,EAAQ,SAAA2E,EAAU,QAAAC,CAAA,EAAWH,EAC9B,CAAC,UAAAjD,EAAW,QAAAqD,GAAW9B,EAAS,UAEhC+B,EAASD,IAAY,SACrBE,EAA0B,CAAA,EAC1BC,EAAmB,CAAA,EACnBC,EAAqB,CAAA,EAG3B,QAAStG,EAAI,EAAGA,EAAI6F,EAAa,OAAQ7F,IAAK,CACpC,MAAAuG,EAAOV,EAAa7F,CAAC,EAG3B,GAAIX,EAAW0G,EAAWQ,EAAK,sBAAsB,EAAG1D,CAAS,EAAG,CAGhE,GAAKmD,EAAS,SAASO,CAAI,EAShBlF,EAAO,SAASkF,CAAI,GAAK,CAACN,EAAQ,SAASM,CAAI,GACtDN,EAAQ,KAAKM,CAAI,UAPbJ,GAAU9E,EAAO,SAASkF,CAAI,EAAG,CACjCD,EAAQ,KAAKC,CAAI,EACjB,QAAA,MAEAF,EAAM,KAAKE,CAAI,EAMvBH,EAAa,KAAKG,CAAI,CAC1B,CACJ,CAGIJ,GACME,EAAA,KAAK,GAAGhF,EAAO,OAAO2B,GAAK,CAACgD,EAAS,SAAShD,CAAC,CAAC,CAAC,EAI3D,MAAMwD,EAAON,IAAY,OACzB,QAASlG,EAAI,EAAGA,EAAIgG,EAAS,OAAQhG,IAAK,CAChC,MAAAuG,EAAOP,EAAShG,CAAC,EAEnB,CAACoG,EAAa,SAASG,CAAI,GAAK,EAIhCC,GAAQnF,EAAO,SAASkF,CAAI,IAE5BD,EAAQ,KAAKC,CAAI,CAEzB,CAEAT,EAAW,SAAWM,EACXN,EAAA,QAAU,CAAC,MAAAO,EAAO,QAAAC,CAAO,EAGpC,KAAK,eAAiB,MAC1B,CAEA,WAAWG,EAA6BxH,EAA8C,CAC3E,OAAA,KAAK,KAAKwH,EAAM,CACnB,MAAOxH,EACP,MAAO,KAAK,WACZ,UAAW,IAAA,CACd,CACL,CAEA,gBAAuB,CACb,KAAA,CAAC,SAAAmF,EAAU,WAAA0B,CAAc,EAAA,KACzB,CAAC,SAAAE,EAAU,QAAAU,EAAS,QAAAT,EAAS,OAAA5E,GAAUyE,EACvCa,EAAgBX,EAAS,OAAOpH,GAAM,CAACyC,EAAO,SAASzC,CAAE,CAAC,EAExD,OAAAwF,EAAS,UAAU,QAAS,CAChC,IAAK,OAAQ,CACT0B,EAAW,OAAS,CAChB,GAAGa,EACH,GAAGtF,EAAO,OAAOzC,GAAM,CAACqH,EAAQ,SAASrH,CAAE,CAAC,CAAA,EAEhD,KACJ,CACA,IAAK,SAAU,CACXkH,EAAW,OAAS,CAChB,GAAGa,EACH,GAAGtF,EAAO,OAAOzC,GAAM,CAAC8H,EAAQ,QAAQ,SAAS9H,CAAE,CAAC,CAAA,EAExD,KACJ,CACA,IAAK,OAAQ,CACTkH,EAAW,OAAS,CAChB,GAAGzE,EACH,GAAG2E,EAAS,OAAOpH,GAAM,CAACyC,EAAO,SAASzC,CAAE,CAAC,CAAA,EAEjD,KACJ,CACJ,CACJ,CAOA,QAAQK,EAA8BgD,EAAS,GAAY,CAClD,KAAA,YAAYhD,EAAKgD,CAAM,CAChC,CAMA,oBAA2B,CACvB,KAAK,aAAetC,EAAU,KAAK,SAAS,YAAa,KAAK,SAAS,QAAQ,CACnF,CAOA,eAAeiH,EAAgB,GAAMC,EAAQ,GAAa,CACtD,KAAM,CAAC,SAAAb,EAAU,OAAA3E,EAAQ,QAAAqF,CAAA,EAAW,KAAK,WAEzCA,EAAQ,MAAQ,GAChBA,EAAQ,QAAQ,KACZ,GAAGV,EACH,GAAIY,EAAgBvF,EAAS,CAAC,CAAA,EAI7BwF,IACI,KAAA,WAAW,OAAQ,IAAI,EACvB,KAAA,WAAW,OAAQ,IAAI,GAIhC,KAAK,WAAazF,EAAmBwF,EAAgB,GAAKvF,CAAM,CACpE,CAKA,cAA0B,CACtB,OAAO,KAAK,WAAW,MAC3B,CAKA,kBAAgC,CAC5B,OAAO,KAAK,KAChB,CAKA,OAAOyF,EAAY,GAAa,CACvB,KAAA,WAAW,KAAM,CAACA,CAAS,CACpC,CAKA,SAAgB,CACZ,KAAK,OAAO,EACZ,KAAK,QAAQ,EACb,KAAK,iBAAiB,SACtB,MAAM,mBAAmB,CAC7B,CAWA,OAAOC,EAA2BF,EAAQ,GAAkB,CACxD,KAAM,CAAC,QAAAH,EAAS,SAAAV,EAAU,OAAA3E,CAAA,EAAU,KAAK,WACnC2F,EAAWrH,EAAUoH,EAAO,KAAK,SAAS,QAAQ,EAAE,OAAOnI,GAC7D,CAACoH,EAAS,SAASpH,CAAE,GACrB,CAACyC,EAAO,SAASzC,CAAE,CAAA,EAIhB,OAAAyC,EAAA,KAAK,GAAG2F,CAAQ,EACdhB,EAAA,KAAK,GAAGgB,CAAQ,EACjBN,EAAA,MAAM,KAAK,GAAGM,CAAQ,EAC9BN,EAAQ,QAAU,GAGlB,KAAK,eAAiB,OAGjBG,IACI,KAAA,WAAW,OAAQ,IAAI,EACvB,KAAA,WAAW,OAAQ,IAAI,GAGzBG,CACX,CAOA,SAASD,EAA2BF,EAAQ,GAAO,CAC/C,KAAM,CAAC,SAAAb,EAAU,OAAA3E,EAAQ,QAAAqF,CAAA,EAAW,KAAK,WAEnCM,EAAWrH,EAAUoH,EAAO,KAAK,SAAS,QAAQ,EAAE,UACtDf,EAAS,SAASpH,CAAE,GACpByC,EAAO,SAASzC,CAAE,CAAA,EAGjBoI,EAAS,SAIT,KAAA,WAAW,OAAS3F,EAAO,UAAa,CAAC2F,EAAS,SAASpI,CAAE,CAAC,EAC9D,KAAA,WAAW,SAAWoH,EAAS,UAAa,CAACgB,EAAS,SAASpI,CAAE,CAAC,EAClE,KAAA,WAAW,QAAQ,MAAQ,CAAA,EAC3B,KAAA,WAAW,QAAQ,QAAQ,KAC5B,GAAGoI,EAAS,OAAOpI,GAAM,CAAC8H,EAAQ,QAAQ,SAAS9H,CAAE,CAAC,CAAA,EAI1D,KAAK,eAAiB,OAGjBiI,IACI,KAAA,WAAW,OAAQ,IAAI,EACvB,KAAA,WAAW,OAAQ,IAAI,GAEpC,CACJ,CA/xBI,OAAAtJ,EADiB+D,EACH,UAAU"}